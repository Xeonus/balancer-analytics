"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""
Indicates exactly one field must be supplied and this field must not be `null`.
"""
directive @oneOf on INPUT_OBJECT

"""
Defined a Subgraph ID for an object type
"""
directive @subgraphId(id: String!) on OBJECT

enum Aggregation_interval {
  day
  hour
}

scalar AmountHumanReadable

type AmpUpdate {
  endAmp: BigInt!
  endTimestamp: BigInt!
  id: ID!
  poolId: Pool!
  scheduledTimestamp: Int!
  startAmp: BigInt!
  startTimestamp: BigInt!
}

input AmpUpdate_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [AmpUpdate_filter]
  endAmp: BigInt
  endAmp_gt: BigInt
  endAmp_gte: BigInt
  endAmp_in: [BigInt!]
  endAmp_lt: BigInt
  endAmp_lte: BigInt
  endAmp_not: BigInt
  endAmp_not_in: [BigInt!]
  endTimestamp: BigInt
  endTimestamp_gt: BigInt
  endTimestamp_gte: BigInt
  endTimestamp_in: [BigInt!]
  endTimestamp_lt: BigInt
  endTimestamp_lte: BigInt
  endTimestamp_not: BigInt
  endTimestamp_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [AmpUpdate_filter]
  poolId: String
  poolId_: Pool_filter
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  scheduledTimestamp: Int
  scheduledTimestamp_gt: Int
  scheduledTimestamp_gte: Int
  scheduledTimestamp_in: [Int!]
  scheduledTimestamp_lt: Int
  scheduledTimestamp_lte: Int
  scheduledTimestamp_not: Int
  scheduledTimestamp_not_in: [Int!]
  startAmp: BigInt
  startAmp_gt: BigInt
  startAmp_gte: BigInt
  startAmp_in: [BigInt!]
  startAmp_lt: BigInt
  startAmp_lte: BigInt
  startAmp_not: BigInt
  startAmp_not_in: [BigInt!]
  startTimestamp: BigInt
  startTimestamp_gt: BigInt
  startTimestamp_gte: BigInt
  startTimestamp_in: [BigInt!]
  startTimestamp_lt: BigInt
  startTimestamp_lte: BigInt
  startTimestamp_not: BigInt
  startTimestamp_not_in: [BigInt!]
}

enum AmpUpdate_orderBy {
  endAmp
  endTimestamp
  id
  poolId
  poolId__address
  poolId__alpha
  poolId__amp
  poolId__baseToken
  poolId__beta
  poolId__c
  poolId__createTime
  poolId__dSq
  poolId__delta
  poolId__epsilon
  poolId__expiryTime
  poolId__factory
  poolId__holdersCount
  poolId__id
  poolId__isInRecoveryMode
  poolId__isPaused
  poolId__joinExitEnabled
  poolId__lambda
  poolId__lastJoinExitAmp
  poolId__lastPostJoinExitInvariant
  poolId__lowerTarget
  poolId__mainIndex
  poolId__managementAumFee
  poolId__managementFee
  poolId__mustAllowlistLPs
  poolId__name
  poolId__oracleEnabled
  poolId__owner
  poolId__poolType
  poolId__poolTypeVersion
  poolId__principalToken
  poolId__protocolAumFeeCache
  poolId__protocolId
  poolId__protocolSwapFeeCache
  poolId__protocolYieldFeeCache
  poolId__root3Alpha
  poolId__s
  poolId__sqrtAlpha
  poolId__sqrtBeta
  poolId__strategyType
  poolId__swapEnabled
  poolId__swapEnabledCurationSignal
  poolId__swapEnabledInternal
  poolId__swapFee
  poolId__swapsCount
  poolId__symbol
  poolId__tauAlphaX
  poolId__tauAlphaY
  poolId__tauBetaX
  poolId__tauBetaY
  poolId__totalAumFeeCollectedInBPT
  poolId__totalLiquidity
  poolId__totalLiquiditySansBPT
  poolId__totalProtocolFee
  poolId__totalProtocolFeePaidInBPT
  poolId__totalShares
  poolId__totalSwapFee
  poolId__totalSwapVolume
  poolId__totalWeight
  poolId__tx
  poolId__u
  poolId__unitSeconds
  poolId__upperTarget
  poolId__v
  poolId__w
  poolId__wrappedIndex
  poolId__z
  scheduledTimestamp
  startAmp
  startTimestamp
}

type Balancer {
  id: ID!
  poolCount: Int!
  pools(
    first: Int = 100
    orderBy: Pool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Pool_filter
  ): [Pool!]
  protocolFeesCollector: Bytes
  snapshots(
    first: Int = 100
    orderBy: BalancerSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: BalancerSnapshot_filter
  ): [BalancerSnapshot!]
  totalLiquidity: BigDecimal!
  totalProtocolFee: BigDecimal
  totalSwapCount: BigInt!
  totalSwapFee: BigDecimal!
  totalSwapVolume: BigDecimal!
}

type BalancerSnapshot {
  id: ID!
  poolCount: Int!
  timestamp: Int!
  totalLiquidity: BigDecimal!
  totalProtocolFee: BigDecimal
  totalSwapCount: BigInt!
  totalSwapFee: BigDecimal!
  totalSwapVolume: BigDecimal!
  vault: Balancer!
}

input BalancerSnapshot_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [BalancerSnapshot_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [BalancerSnapshot_filter]
  poolCount: Int
  poolCount_gt: Int
  poolCount_gte: Int
  poolCount_in: [Int!]
  poolCount_lt: Int
  poolCount_lte: Int
  poolCount_not: Int
  poolCount_not_in: [Int!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  totalLiquidity: BigDecimal
  totalLiquidity_gt: BigDecimal
  totalLiquidity_gte: BigDecimal
  totalLiquidity_in: [BigDecimal!]
  totalLiquidity_lt: BigDecimal
  totalLiquidity_lte: BigDecimal
  totalLiquidity_not: BigDecimal
  totalLiquidity_not_in: [BigDecimal!]
  totalProtocolFee: BigDecimal
  totalProtocolFee_gt: BigDecimal
  totalProtocolFee_gte: BigDecimal
  totalProtocolFee_in: [BigDecimal!]
  totalProtocolFee_lt: BigDecimal
  totalProtocolFee_lte: BigDecimal
  totalProtocolFee_not: BigDecimal
  totalProtocolFee_not_in: [BigDecimal!]
  totalSwapCount: BigInt
  totalSwapCount_gt: BigInt
  totalSwapCount_gte: BigInt
  totalSwapCount_in: [BigInt!]
  totalSwapCount_lt: BigInt
  totalSwapCount_lte: BigInt
  totalSwapCount_not: BigInt
  totalSwapCount_not_in: [BigInt!]
  totalSwapFee: BigDecimal
  totalSwapFee_gt: BigDecimal
  totalSwapFee_gte: BigDecimal
  totalSwapFee_in: [BigDecimal!]
  totalSwapFee_lt: BigDecimal
  totalSwapFee_lte: BigDecimal
  totalSwapFee_not: BigDecimal
  totalSwapFee_not_in: [BigDecimal!]
  totalSwapVolume: BigDecimal
  totalSwapVolume_gt: BigDecimal
  totalSwapVolume_gte: BigDecimal
  totalSwapVolume_in: [BigDecimal!]
  totalSwapVolume_lt: BigDecimal
  totalSwapVolume_lte: BigDecimal
  totalSwapVolume_not: BigDecimal
  totalSwapVolume_not_in: [BigDecimal!]
  vault: String
  vault_: Balancer_filter
  vault_contains: String
  vault_contains_nocase: String
  vault_ends_with: String
  vault_ends_with_nocase: String
  vault_gt: String
  vault_gte: String
  vault_in: [String!]
  vault_lt: String
  vault_lte: String
  vault_not: String
  vault_not_contains: String
  vault_not_contains_nocase: String
  vault_not_ends_with: String
  vault_not_ends_with_nocase: String
  vault_not_in: [String!]
  vault_not_starts_with: String
  vault_not_starts_with_nocase: String
  vault_starts_with: String
  vault_starts_with_nocase: String
}

enum BalancerSnapshot_orderBy {
  id
  poolCount
  timestamp
  totalLiquidity
  totalProtocolFee
  totalSwapCount
  totalSwapFee
  totalSwapVolume
  vault
  vault__id
  vault__poolCount
  vault__protocolFeesCollector
  vault__totalLiquidity
  vault__totalProtocolFee
  vault__totalSwapCount
  vault__totalSwapFee
  vault__totalSwapVolume
}

input Balancer_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Balancer_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [Balancer_filter]
  poolCount: Int
  poolCount_gt: Int
  poolCount_gte: Int
  poolCount_in: [Int!]
  poolCount_lt: Int
  poolCount_lte: Int
  poolCount_not: Int
  poolCount_not_in: [Int!]
  pools_: Pool_filter
  protocolFeesCollector: Bytes
  protocolFeesCollector_contains: Bytes
  protocolFeesCollector_gt: Bytes
  protocolFeesCollector_gte: Bytes
  protocolFeesCollector_in: [Bytes!]
  protocolFeesCollector_lt: Bytes
  protocolFeesCollector_lte: Bytes
  protocolFeesCollector_not: Bytes
  protocolFeesCollector_not_contains: Bytes
  protocolFeesCollector_not_in: [Bytes!]
  snapshots_: BalancerSnapshot_filter
  totalLiquidity: BigDecimal
  totalLiquidity_gt: BigDecimal
  totalLiquidity_gte: BigDecimal
  totalLiquidity_in: [BigDecimal!]
  totalLiquidity_lt: BigDecimal
  totalLiquidity_lte: BigDecimal
  totalLiquidity_not: BigDecimal
  totalLiquidity_not_in: [BigDecimal!]
  totalProtocolFee: BigDecimal
  totalProtocolFee_gt: BigDecimal
  totalProtocolFee_gte: BigDecimal
  totalProtocolFee_in: [BigDecimal!]
  totalProtocolFee_lt: BigDecimal
  totalProtocolFee_lte: BigDecimal
  totalProtocolFee_not: BigDecimal
  totalProtocolFee_not_in: [BigDecimal!]
  totalSwapCount: BigInt
  totalSwapCount_gt: BigInt
  totalSwapCount_gte: BigInt
  totalSwapCount_in: [BigInt!]
  totalSwapCount_lt: BigInt
  totalSwapCount_lte: BigInt
  totalSwapCount_not: BigInt
  totalSwapCount_not_in: [BigInt!]
  totalSwapFee: BigDecimal
  totalSwapFee_gt: BigDecimal
  totalSwapFee_gte: BigDecimal
  totalSwapFee_in: [BigDecimal!]
  totalSwapFee_lt: BigDecimal
  totalSwapFee_lte: BigDecimal
  totalSwapFee_not: BigDecimal
  totalSwapFee_not_in: [BigDecimal!]
  totalSwapVolume: BigDecimal
  totalSwapVolume_gt: BigDecimal
  totalSwapVolume_gte: BigDecimal
  totalSwapVolume_in: [BigDecimal!]
  totalSwapVolume_lt: BigDecimal
  totalSwapVolume_lte: BigDecimal
  totalSwapVolume_not: BigDecimal
  totalSwapVolume_not_in: [BigDecimal!]
}

enum Balancer_orderBy {
  id
  poolCount
  pools
  protocolFeesCollector
  snapshots
  totalLiquidity
  totalProtocolFee
  totalSwapCount
  totalSwapFee
  totalSwapVolume
}

scalar BigDecimal

scalar BigInt

type Block {
  author: String
  difficulty: BigInt
  gasLimit: BigInt
  gasUsed: BigInt
  id: ID!
  number: BigInt!
  parentHash: String
  receiptsRoot: String
  size: BigInt
  stateRoot: String
  timestamp: BigInt!
  totalDifficulty: BigInt
  transactionsRoot: String
  unclesHash: String
}

input BlockChangedFilter {
  number_gte: Int!
}

input Block_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Block_filter]
  author: String
  author_contains: String
  author_contains_nocase: String
  author_ends_with: String
  author_ends_with_nocase: String
  author_gt: String
  author_gte: String
  author_in: [String!]
  author_lt: String
  author_lte: String
  author_not: String
  author_not_contains: String
  author_not_contains_nocase: String
  author_not_ends_with: String
  author_not_ends_with_nocase: String
  author_not_in: [String!]
  author_not_starts_with: String
  author_not_starts_with_nocase: String
  author_starts_with: String
  author_starts_with_nocase: String
  difficulty: BigInt
  difficulty_gt: BigInt
  difficulty_gte: BigInt
  difficulty_in: [BigInt!]
  difficulty_lt: BigInt
  difficulty_lte: BigInt
  difficulty_not: BigInt
  difficulty_not_in: [BigInt!]
  gasLimit: BigInt
  gasLimit_gt: BigInt
  gasLimit_gte: BigInt
  gasLimit_in: [BigInt!]
  gasLimit_lt: BigInt
  gasLimit_lte: BigInt
  gasLimit_not: BigInt
  gasLimit_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_gt: BigInt
  gasUsed_gte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_lt: BigInt
  gasUsed_lte: BigInt
  gasUsed_not: BigInt
  gasUsed_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  number: BigInt
  number_gt: BigInt
  number_gte: BigInt
  number_in: [BigInt!]
  number_lt: BigInt
  number_lte: BigInt
  number_not: BigInt
  number_not_in: [BigInt!]
  or: [Block_filter]
  parentHash: String
  parentHash_contains: String
  parentHash_contains_nocase: String
  parentHash_ends_with: String
  parentHash_ends_with_nocase: String
  parentHash_gt: String
  parentHash_gte: String
  parentHash_in: [String!]
  parentHash_lt: String
  parentHash_lte: String
  parentHash_not: String
  parentHash_not_contains: String
  parentHash_not_contains_nocase: String
  parentHash_not_ends_with: String
  parentHash_not_ends_with_nocase: String
  parentHash_not_in: [String!]
  parentHash_not_starts_with: String
  parentHash_not_starts_with_nocase: String
  parentHash_starts_with: String
  parentHash_starts_with_nocase: String
  receiptsRoot: String
  receiptsRoot_contains: String
  receiptsRoot_contains_nocase: String
  receiptsRoot_ends_with: String
  receiptsRoot_ends_with_nocase: String
  receiptsRoot_gt: String
  receiptsRoot_gte: String
  receiptsRoot_in: [String!]
  receiptsRoot_lt: String
  receiptsRoot_lte: String
  receiptsRoot_not: String
  receiptsRoot_not_contains: String
  receiptsRoot_not_contains_nocase: String
  receiptsRoot_not_ends_with: String
  receiptsRoot_not_ends_with_nocase: String
  receiptsRoot_not_in: [String!]
  receiptsRoot_not_starts_with: String
  receiptsRoot_not_starts_with_nocase: String
  receiptsRoot_starts_with: String
  receiptsRoot_starts_with_nocase: String
  size: BigInt
  size_gt: BigInt
  size_gte: BigInt
  size_in: [BigInt!]
  size_lt: BigInt
  size_lte: BigInt
  size_not: BigInt
  size_not_in: [BigInt!]
  stateRoot: String
  stateRoot_contains: String
  stateRoot_contains_nocase: String
  stateRoot_ends_with: String
  stateRoot_ends_with_nocase: String
  stateRoot_gt: String
  stateRoot_gte: String
  stateRoot_in: [String!]
  stateRoot_lt: String
  stateRoot_lte: String
  stateRoot_not: String
  stateRoot_not_contains: String
  stateRoot_not_contains_nocase: String
  stateRoot_not_ends_with: String
  stateRoot_not_ends_with_nocase: String
  stateRoot_not_in: [String!]
  stateRoot_not_starts_with: String
  stateRoot_not_starts_with_nocase: String
  stateRoot_starts_with: String
  stateRoot_starts_with_nocase: String
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  totalDifficulty: BigInt
  totalDifficulty_gt: BigInt
  totalDifficulty_gte: BigInt
  totalDifficulty_in: [BigInt!]
  totalDifficulty_lt: BigInt
  totalDifficulty_lte: BigInt
  totalDifficulty_not: BigInt
  totalDifficulty_not_in: [BigInt!]
  transactionsRoot: String
  transactionsRoot_contains: String
  transactionsRoot_contains_nocase: String
  transactionsRoot_ends_with: String
  transactionsRoot_ends_with_nocase: String
  transactionsRoot_gt: String
  transactionsRoot_gte: String
  transactionsRoot_in: [String!]
  transactionsRoot_lt: String
  transactionsRoot_lte: String
  transactionsRoot_not: String
  transactionsRoot_not_contains: String
  transactionsRoot_not_contains_nocase: String
  transactionsRoot_not_ends_with: String
  transactionsRoot_not_ends_with_nocase: String
  transactionsRoot_not_in: [String!]
  transactionsRoot_not_starts_with: String
  transactionsRoot_not_starts_with_nocase: String
  transactionsRoot_starts_with: String
  transactionsRoot_starts_with_nocase: String
  unclesHash: String
  unclesHash_contains: String
  unclesHash_contains_nocase: String
  unclesHash_ends_with: String
  unclesHash_ends_with_nocase: String
  unclesHash_gt: String
  unclesHash_gte: String
  unclesHash_in: [String!]
  unclesHash_lt: String
  unclesHash_lte: String
  unclesHash_not: String
  unclesHash_not_contains: String
  unclesHash_not_contains_nocase: String
  unclesHash_not_ends_with: String
  unclesHash_not_ends_with_nocase: String
  unclesHash_not_in: [String!]
  unclesHash_not_starts_with: String
  unclesHash_not_starts_with_nocase: String
  unclesHash_starts_with: String
  unclesHash_starts_with_nocase: String
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

enum Block_orderBy {
  author
  difficulty
  gasLimit
  gasUsed
  id
  number
  parentHash
  receiptsRoot
  size
  stateRoot
  timestamp
  totalDifficulty
  transactionsRoot
  unclesHash
}

scalar Bytes

enum Chain {
  Arbitrum
  Avalanche
  Base
  Fraxtal
  Gnosis
  Optimism
  Polygon
  PolygonZkEvm
}

type CircuitBreaker {
  bptPrice: BigDecimal!
  id: ID!
  lowerBoundPercentage: BigDecimal!
  pool: Pool!
  token: PoolToken!
  upperBoundPercentage: BigDecimal!
}

input CircuitBreaker_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [CircuitBreaker_filter]
  bptPrice: BigDecimal
  bptPrice_gt: BigDecimal
  bptPrice_gte: BigDecimal
  bptPrice_in: [BigDecimal!]
  bptPrice_lt: BigDecimal
  bptPrice_lte: BigDecimal
  bptPrice_not: BigDecimal
  bptPrice_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lowerBoundPercentage: BigDecimal
  lowerBoundPercentage_gt: BigDecimal
  lowerBoundPercentage_gte: BigDecimal
  lowerBoundPercentage_in: [BigDecimal!]
  lowerBoundPercentage_lt: BigDecimal
  lowerBoundPercentage_lte: BigDecimal
  lowerBoundPercentage_not: BigDecimal
  lowerBoundPercentage_not_in: [BigDecimal!]
  or: [CircuitBreaker_filter]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  token: String
  token_: PoolToken_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  upperBoundPercentage: BigDecimal
  upperBoundPercentage_gt: BigDecimal
  upperBoundPercentage_gte: BigDecimal
  upperBoundPercentage_in: [BigDecimal!]
  upperBoundPercentage_lt: BigDecimal
  upperBoundPercentage_lte: BigDecimal
  upperBoundPercentage_not: BigDecimal
  upperBoundPercentage_not_in: [BigDecimal!]
}

enum CircuitBreaker_orderBy {
  bptPrice
  id
  lowerBoundPercentage
  pool
  pool__address
  pool__alpha
  pool__amp
  pool__baseToken
  pool__beta
  pool__c
  pool__createTime
  pool__dSq
  pool__delta
  pool__epsilon
  pool__expiryTime
  pool__factory
  pool__holdersCount
  pool__id
  pool__isInRecoveryMode
  pool__isPaused
  pool__joinExitEnabled
  pool__lambda
  pool__lastJoinExitAmp
  pool__lastPostJoinExitInvariant
  pool__lowerTarget
  pool__mainIndex
  pool__managementAumFee
  pool__managementFee
  pool__mustAllowlistLPs
  pool__name
  pool__oracleEnabled
  pool__owner
  pool__poolType
  pool__poolTypeVersion
  pool__principalToken
  pool__protocolAumFeeCache
  pool__protocolId
  pool__protocolSwapFeeCache
  pool__protocolYieldFeeCache
  pool__root3Alpha
  pool__s
  pool__sqrtAlpha
  pool__sqrtBeta
  pool__strategyType
  pool__swapEnabled
  pool__swapEnabledCurationSignal
  pool__swapEnabledInternal
  pool__swapFee
  pool__swapsCount
  pool__symbol
  pool__tauAlphaX
  pool__tauAlphaY
  pool__tauBetaX
  pool__tauBetaY
  pool__totalAumFeeCollectedInBPT
  pool__totalLiquidity
  pool__totalLiquiditySansBPT
  pool__totalProtocolFee
  pool__totalProtocolFeePaidInBPT
  pool__totalShares
  pool__totalSwapFee
  pool__totalSwapVolume
  pool__totalWeight
  pool__tx
  pool__u
  pool__unitSeconds
  pool__upperTarget
  pool__v
  pool__w
  pool__wrappedIndex
  pool__z
  token
  token__address
  token__assetManager
  token__balance
  token__cashBalance
  token__decimals
  token__id
  token__index
  token__isExemptFromYieldProtocolFee
  token__managedBalance
  token__name
  token__oldPriceRate
  token__paidProtocolFees
  token__priceRate
  token__symbol
  token__weight
  upperBoundPercentage
}

input CreateLBPInput {
  metadata: LBPMetadataInput!
  poolContract: LBPoolInput!
}

scalar Date

"""
The review data for the ERC4626 token
"""
type Erc4626ReviewData {
  """
  If it is an ERC4626 token, this defines whether we can use wrap/unwrap through the buffer in swap paths for this token.
  """
  canUseBufferForSwaps: Boolean

  """
  The filename of the review of the ERC4626
  """
  reviewFile: String!

  """
  A summary of the ERC4626 review, usually just says safe or unsafe
  """
  summary: String!

  """
  If it is an ERC4626 token, this defines whether we allow underlying tokens to be used for add/remove operations.
  """
  useUnderlyingForAddRemove: Boolean

  """
  If it is an ERC4626 token, this defines whether we allow the wrapped tokens to be used for add/remove operations.
  """
  useWrappedForAddRemove: Boolean

  """
  Warnings associated with the ERC4626
  """
  warnings: [String!]!
}

"""
ExitFee hook specific params. Percentage format is 0.01 -> 0.01%.
"""
type ExitFeeHookParams {
  exitFeePercentage: String
}

type FXOracle {
  decimals: Int
  divisor: String
  id: ID!
  tokens: [Bytes!]!
}

input FXOracle_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [FXOracle_filter]
  decimals: Int
  decimals_gt: Int
  decimals_gte: Int
  decimals_in: [Int!]
  decimals_lt: Int
  decimals_lte: Int
  decimals_not: Int
  decimals_not_in: [Int!]
  divisor: String
  divisor_contains: String
  divisor_contains_nocase: String
  divisor_ends_with: String
  divisor_ends_with_nocase: String
  divisor_gt: String
  divisor_gte: String
  divisor_in: [String!]
  divisor_lt: String
  divisor_lte: String
  divisor_not: String
  divisor_not_contains: String
  divisor_not_contains_nocase: String
  divisor_not_ends_with: String
  divisor_not_ends_with_nocase: String
  divisor_not_in: [String!]
  divisor_not_starts_with: String
  divisor_not_starts_with_nocase: String
  divisor_starts_with: String
  divisor_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [FXOracle_filter]
  tokens: [Bytes!]
  tokens_contains: [Bytes!]
  tokens_contains_nocase: [Bytes!]
  tokens_not: [Bytes!]
  tokens_not_contains: [Bytes!]
  tokens_not_contains_nocase: [Bytes!]
}

enum FXOracle_orderBy {
  decimals
  divisor
  id
  tokens
}

"""
FeeTaking hook specific params. Percentage format is 0.01 -> 0.01%
"""
type FeeTakingHookParams {
  addLiquidityFeePercentage: String
  removeLiquidityFeePercentage: String
  swapFeePercentage: String
}

type Gauge {
  """
  Timestamp at which Balancer DAO added the gauge to GaugeController [seconds]
  """
  addedTimestamp: Int!

  """
  Address of the gauge
  """
  address: Bytes!

  """
  Equal to: <gaugeAddress>-<typeID>
  """
  id: ID!

  """
  Reference to LiquidityGauge
  """
  liquidityGauge: LiquidityGauge

  """
  Reference to RootGauge
  """
  rootGauge: RootGauge

  """
  Type of the gauge
  """
  type: GaugeType!
}

type GaugeFactory {
  """
  List of gauges created through the factory
  """
  gauges(
    first: Int = 100
    orderBy: LiquidityGauge_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LiquidityGauge_filter
  ): [LiquidityGauge!]

  """
  Factory contract address
  """
  id: ID!

  """
  Number of gauges created through the factory
  """
  numGauges: Int!
}

input GaugeFactory_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [GaugeFactory_filter]
  gauges_: LiquidityGauge_filter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  numGauges: Int
  numGauges_gt: Int
  numGauges_gte: Int
  numGauges_in: [Int!]
  numGauges_lt: Int
  numGauges_lte: Int
  numGauges_not: Int
  numGauges_not_in: [Int!]
  or: [GaugeFactory_filter]
}

enum GaugeFactory_orderBy {
  gauges
  id
  numGauges
}

type GaugeInjector {
  """
  GaugeInjector contract address
  """
  id: ID!
}

input GaugeInjector_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [GaugeInjector_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [GaugeInjector_filter]
}

enum GaugeInjector_orderBy {
  id
}

type GaugeShare {
  """
  User's balance of gauge deposit tokens
  """
  balance: BigDecimal!

  """
  Reference to LiquidityGauge entity
  """
  gauge: LiquidityGauge!

  """
  Equal to: <userAddress>-<gaugeAddress>
  """
  id: ID!

  """
  Reference to User entity
  """
  user: User!
}

input GaugeShare_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [GaugeShare_filter]
  balance: BigDecimal
  balance_gt: BigDecimal
  balance_gte: BigDecimal
  balance_in: [BigDecimal!]
  balance_lt: BigDecimal
  balance_lte: BigDecimal
  balance_not: BigDecimal
  balance_not_in: [BigDecimal!]
  gauge: String
  gauge_: LiquidityGauge_filter
  gauge_contains: String
  gauge_contains_nocase: String
  gauge_ends_with: String
  gauge_ends_with_nocase: String
  gauge_gt: String
  gauge_gte: String
  gauge_in: [String!]
  gauge_lt: String
  gauge_lte: String
  gauge_not: String
  gauge_not_contains: String
  gauge_not_contains_nocase: String
  gauge_not_ends_with: String
  gauge_not_ends_with_nocase: String
  gauge_not_in: [String!]
  gauge_not_starts_with: String
  gauge_not_starts_with_nocase: String
  gauge_starts_with: String
  gauge_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [GaugeShare_filter]
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum GaugeShare_orderBy {
  balance
  gauge
  gauge__id
  gauge__isKilled
  gauge__isPreferentialGauge
  gauge__poolAddress
  gauge__poolId
  gauge__relativeWeightCap
  gauge__streamer
  gauge__symbol
  gauge__totalSupply
  id
  user
  user__id
}

type GaugeType {
  """
  Type ID
  """
  id: ID!

  """
  Name of the type - empty string if call reverts
  """
  name: String!
}

input GaugeType_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [GaugeType_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  name: String
  name_contains: String
  name_contains_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  or: [GaugeType_filter]
}

enum GaugeType_orderBy {
  id
  name
}

type GaugeVote {
  """
  Reference to Gauge entity
  """
  gauge: Gauge!

  """
  Equal to: <userAddress>-<gaugeAddress>
  """
  id: ID!

  """
  Timestamp at which user voted [seconds]
  """
  timestamp: BigInt

  """
  Reference to User entity
  """
  user: User!

  """
  Weight of veBAL power user has used to vote
  """
  weight: BigDecimal
}

input GaugeVote_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [GaugeVote_filter]
  gauge: String
  gauge_: Gauge_filter
  gauge_contains: String
  gauge_contains_nocase: String
  gauge_ends_with: String
  gauge_ends_with_nocase: String
  gauge_gt: String
  gauge_gte: String
  gauge_in: [String!]
  gauge_lt: String
  gauge_lte: String
  gauge_not: String
  gauge_not_contains: String
  gauge_not_contains_nocase: String
  gauge_not_ends_with: String
  gauge_not_ends_with_nocase: String
  gauge_not_in: [String!]
  gauge_not_starts_with: String
  gauge_not_starts_with_nocase: String
  gauge_starts_with: String
  gauge_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [GaugeVote_filter]
  timestamp: BigInt
  timestamp_gt: BigInt
  timestamp_gte: BigInt
  timestamp_in: [BigInt!]
  timestamp_lt: BigInt
  timestamp_lte: BigInt
  timestamp_not: BigInt
  timestamp_not_in: [BigInt!]
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
  weight: BigDecimal
  weight_gt: BigDecimal
  weight_gte: BigDecimal
  weight_in: [BigDecimal!]
  weight_lt: BigDecimal
  weight_lte: BigDecimal
  weight_not: BigDecimal
  weight_not_in: [BigDecimal!]
}

enum GaugeVote_orderBy {
  gauge
  gauge__addedTimestamp
  gauge__address
  gauge__id
  id
  timestamp
  user
  user__id
  weight
}

input Gauge_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  addedTimestamp: Int
  addedTimestamp_gt: Int
  addedTimestamp_gte: Int
  addedTimestamp_in: [Int!]
  addedTimestamp_lt: Int
  addedTimestamp_lte: Int
  addedTimestamp_not: Int
  addedTimestamp_not_in: [Int!]
  address: Bytes
  address_contains: Bytes
  address_gt: Bytes
  address_gte: Bytes
  address_in: [Bytes!]
  address_lt: Bytes
  address_lte: Bytes
  address_not: Bytes
  address_not_contains: Bytes
  address_not_in: [Bytes!]
  and: [Gauge_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidityGauge: String
  liquidityGauge_: LiquidityGauge_filter
  liquidityGauge_contains: String
  liquidityGauge_contains_nocase: String
  liquidityGauge_ends_with: String
  liquidityGauge_ends_with_nocase: String
  liquidityGauge_gt: String
  liquidityGauge_gte: String
  liquidityGauge_in: [String!]
  liquidityGauge_lt: String
  liquidityGauge_lte: String
  liquidityGauge_not: String
  liquidityGauge_not_contains: String
  liquidityGauge_not_contains_nocase: String
  liquidityGauge_not_ends_with: String
  liquidityGauge_not_ends_with_nocase: String
  liquidityGauge_not_in: [String!]
  liquidityGauge_not_starts_with: String
  liquidityGauge_not_starts_with_nocase: String
  liquidityGauge_starts_with: String
  liquidityGauge_starts_with_nocase: String
  or: [Gauge_filter]
  rootGauge: String
  rootGauge_: RootGauge_filter
  rootGauge_contains: String
  rootGauge_contains_nocase: String
  rootGauge_ends_with: String
  rootGauge_ends_with_nocase: String
  rootGauge_gt: String
  rootGauge_gte: String
  rootGauge_in: [String!]
  rootGauge_lt: String
  rootGauge_lte: String
  rootGauge_not: String
  rootGauge_not_contains: String
  rootGauge_not_contains_nocase: String
  rootGauge_not_ends_with: String
  rootGauge_not_ends_with_nocase: String
  rootGauge_not_in: [String!]
  rootGauge_not_starts_with: String
  rootGauge_not_starts_with_nocase: String
  rootGauge_starts_with: String
  rootGauge_starts_with_nocase: String
  type: String
  type_: GaugeType_filter
  type_contains: String
  type_contains_nocase: String
  type_ends_with: String
  type_ends_with_nocase: String
  type_gt: String
  type_gte: String
  type_in: [String!]
  type_lt: String
  type_lte: String
  type_not: String
  type_not_contains: String
  type_not_contains_nocase: String
  type_not_ends_with: String
  type_not_ends_with_nocase: String
  type_not_in: [String!]
  type_not_starts_with: String
  type_not_starts_with_nocase: String
  type_starts_with: String
  type_starts_with_nocase: String
}

enum Gauge_orderBy {
  addedTimestamp
  address
  id
  liquidityGauge
  liquidityGauge__id
  liquidityGauge__isKilled
  liquidityGauge__isPreferentialGauge
  liquidityGauge__poolAddress
  liquidityGauge__poolId
  liquidityGauge__relativeWeightCap
  liquidityGauge__streamer
  liquidityGauge__symbol
  liquidityGauge__totalSupply
  rootGauge
  rootGauge__chain
  rootGauge__id
  rootGauge__isKilled
  rootGauge__recipient
  rootGauge__relativeWeightCap
  type
  type__id
  type__name
}

input GqlAggregatorPoolFilter {
  chainIn: [GqlChain!]
  idIn: [String!]
  includeHooks: [GqlHookType!]
  minTvl: Float
  poolTypeIn: [GqlPoolType!]
  protocolVersionIn: [Int!]
  tokensIn: [String!]
}

scalar GqlBigNumber

enum GqlChain {
  ARBITRUM
  AVALANCHE
  BASE
  FANTOM
  FRAXTAL
  GNOSIS
  HYPEREVM
  MAINNET
  MODE
  MONAD
  OPTIMISM
  PLASMA
  POLYGON
  SEPOLIA
  SONIC
  XLAYER
  ZKEVM
}

type GqlHistoricalTokenPrice {
  address: String!
  chain: GqlChain!
  prices: [GqlHistoricalTokenPriceEntry!]!
}

type GqlHistoricalTokenPriceEntry {
  price: Float!
  timestamp: String!
  updatedAt: Int!
  updatedBy: String
}

"""
Hook data
"""
type GqlHook {
  address: String!
  config: HookConfig
  dynamicData: GqlHookData @deprecated
  enableHookAdjustedAmounts: Boolean! @deprecated
  name: String! @deprecated(reason: "unused")

  """
  Hook type specific params
  """
  params: HookParams

  """
  The review for this hook if applicable.
  """
  reviewData: GqlHookReviewData
  shouldCallAfterAddLiquidity: Boolean! @deprecated
  shouldCallAfterInitialize: Boolean! @deprecated
  shouldCallAfterRemoveLiquidity: Boolean! @deprecated
  shouldCallAfterSwap: Boolean! @deprecated
  shouldCallBeforeAddLiquidity: Boolean! @deprecated
  shouldCallBeforeInitialize: Boolean! @deprecated
  shouldCallBeforeRemoveLiquidity: Boolean! @deprecated
  shouldCallBeforeSwap: Boolean! @deprecated
  shouldCallComputeDynamicSwapFee: Boolean! @deprecated
  type: GqlHookType!
}

type GqlHookData {
  addLiquidityFeePercentage: String
  maxSurgeFeePercentage: String
  removeLiquidityFeePercentage: String
  surgeThresholdPercentage: String
  swapFeePercentage: String
}

"""
Represents the review data for the hook
"""
type GqlHookReviewData {
  """
  The filename of the review of the hook
  """
  reviewFile: String!

  """
  A summary of the hook review, usually just says safe or unsafe
  """
  summary: String!

  """
  Warnings associated with the hook
  """
  warnings: [String!]!
}

enum GqlHookType {
  AKRON
  DIRECTIONAL_FEE
  EXIT_FEE
  FEE_TAKING
  LBP
  LOTTERY
  MEV_TAX
  NFTLIQUIDITY_POSITION
  RECLAMM
  STABLE_SURGE
  UNKNOWN
  VEBAL_DISCOUNT
}

type GqlLBPTopTrade {
  address: String!
  timestamp: String!
  value: String!
}

type GqlLoopsData {
  """
  Actual TotalSupply of LoopS.
  """
  actualSupply: String!

  """
  The total APR for LoopS
  """
  apr: Float!

  """
  The amount of stS provided to Aave.
  """
  collateralAmount: String!

  """
  The amount of stS provided to Aave in S.
  """
  collateralAmountInEth: String!

  """
  The total S debt amount of the position
  """
  debtAmount: String!

  """
  The health factor of the Aave position
  """
  healthFactor: String!

  """
  The amount of leverage the current position has.
  """
  leverage: Float!

  """
  Net Asset Value. The amount of collateral minus the amount of debt.
  """
  nav: String!

  """
  The current rate of LoopS against S.
  """
  rate: String!

  """
  The current amount of stS supplied to the Aave market
  """
  stSAaveMarketSupply: String!

  """
  The current cap on the stS market on Aave
  """
  stSAaveMarketSupplyCap: String!

  """
  Net Asset Value in USD.
  """
  tvl: String!
}

"""
All info on the nested pool if the token is a BPT. It will only support 1 level of nesting.
"""
type GqlNestedPool {
  """
  Address of the pool.
  """
  address: Bytes!

  """
  Price rate of this pool or the Balancer Pool Token (BPT).
  """
  bptPriceRate: BigDecimal!

  """
  Timestamp of when the pool was created.
  """
  createTime: Int!

  """
  Address of the factory contract that created the pool, if applicable.
  """
  factory: Bytes

  """
  Hook assigned to a pool
  """
  hook: GqlHook

  """
  Unique identifier of the pool.
  """
  id: ID!

  """
  Liquidity management settings for v3 pools.
  """
  liquidityManagement: LiquidityManagement

  """
  Name of the pool.
  """
  name: String!

  """
  Total liquidity of the parent pool in the nested pool in USD.
  """
  nestedLiquidity: BigDecimal!

  """
  Percentage of the parents pool shares inside the nested pool.
  """
  nestedPercentage: BigDecimal!

  """
  Number of shares of the parent pool in the nested pool.
  """
  nestedShares: BigDecimal!

  """
  The wallet address of the owner of the pool. Pool owners can set certain properties like swapFees or AMP.
  """
  owner: Bytes @deprecated(reason: "Use swapFeeManager instead")

  """
  Account empowered to pause/unpause the pool (or 0 to delegate to governance)
  """
  pauseManager: Bytes

  """
  Account empowered to set the pool creator fee percentage
  """
  poolCreator: Bytes

  """
  Fee charged for swapping tokens in the pool as %. 0.01 -> 0.01%
  """
  swapFee: BigDecimal!

  """
  Account empowered to set static swap fees for a pool (when 0 on V2 swap fees are immutable, on V3 delegate to governance)
  """
  swapFeeManager: Bytes

  """
  Symbol of the pool.
  """
  symbol: String!

  """
  List of all tokens in the pool.
  """
  tokens: [GqlPoolTokenDetail!]!

  """
  Total liquidity in the pool in USD.
  """
  totalLiquidity: BigDecimal!

  """
  Total number of shares in the pool.
  """
  totalShares: BigDecimal!

  """
  Type of the pool.
  """
  type: GqlPoolType!

  """
  Version of the pool.
  """
  version: Int!
}

"""
Represents an event that occurs when liquidity is added or removed from a pool.
"""
type GqlPoolAddRemoveEventV3 implements GqlPoolEvent {
  """
  The block number of the event.
  """
  blockNumber: Int!

  """
  The block timestamp of the event.
  """
  blockTimestamp: Int!

  """
  The chain on which the event occurred.
  """
  chain: GqlChain!

  """
  The unique identifier of the event.
  """
  id: ID!

  """
  The log index of the event.
  """
  logIndex: Int!

  """
  The pool ID associated with the event.
  """
  poolId: String!

  """
  The sender of the event.
  """
  sender: String!

  """
  The timestamp of the event.
  """
  timestamp: Int!

  """
  The tokens involved in the event. Ordered by poolToken index.
  """
  tokens: [GqlPoolEventAmount!]!

  """
  The transaction hash of the event.
  """
  tx: String!

  """
  The type of the event.
  """
  type: GqlPoolEventType!

  """
  The user address associated with the event.
  """
  userAddress: String!

  """
  The value of the event in USD.
  """
  valueUSD: Float!
}

type GqlPoolAggregator {
  """
  The contract address of the pool.
  """
  address: Bytes!

  """
  Data specific to gyro/fx pools
  """
  alpha: String

  """
  Data specific to stable pools
  """
  amp: BigInt

  """
  Data specific to gyro/fx pools
  """
  beta: String

  """
  Data specific to gyro pools
  """
  c: String

  """
  ReClamm: The centeredness margin of the pool
  """
  centerednessMargin: BigDecimal

  """
  The chain on which the pool is deployed
  """
  chain: GqlChain!

  """
  The timestamp the pool was created.
  """
  createTime: Int!

  """
  ReClamm: The current fourth root price ratio, an interpolation of the price ratio state
  """
  currentFourthRootPriceRatio: BigDecimal

  """
  Data specific to gyro pools
  """
  dSq: String

  """
  ReClamm: Represents how fast the pool can move the virtual balances per day
  """
  dailyPriceShiftBase: BigDecimal

  """
  The decimals of the BPT, usually 18
  """
  decimals: Int!

  """
  Data specific to fx pools
  """
  delta: String

  """
  Dynamic data such as token balances, swap fees or volume
  """
  dynamicData: GqlPoolDynamicData!

  """
  ReClamm: The fourth root price ratio at the end of an update
  """
  endFourthRootPriceRatio: BigDecimal

  """
  Data specific to fx pools
  """
  epsilon: String

  """
  The factory contract address from which the pool was created.
  """
  factory: Bytes

  """
  Hook assigned to a pool
  """
  hook: GqlHook

  """
  The pool id. This is equal to the address for protocolVersion 3 pools
  """
  id: ID!

  """
  Data specific to gyro/fx pools
  """
  lambda: String

  """
  The timestamp of the last user interaction
  """
  lastTimestamp: Int

  """
  ReClamm: The last virtual balances of the pool
  """
  lastVirtualBalances: [BigDecimal!]

  """
  Liquidity management settings for v3 pools.
  """
  liquidityManagement: LiquidityManagement

  """
  The name of the pool as per contract
  """
  name: String!

  """
  The wallet address of the owner of the pool. Pool owners can set certain properties like swapFees or AMP.
  """
  owner: Bytes @deprecated(reason: "Use swapFeeManager instead")

  """
  Account empowered to pause/unpause the pool (or 0 to delegate to governance)
  """
  pauseManager: Bytes

  """
  Account empowered to set the pool creator fee percentage
  """
  poolCreator: Bytes

  """
  Returns all pool tokens, including BPTs and nested pools if there are any. Only one nested level deep.
  """
  poolTokens: [GqlPoolTokenDetail!]!

  """
  ReClamm: The timestamp when the update ends
  """
  priceRatioUpdateEndTime: Int

  """
  ReClamm: The timestamp when the update begins
  """
  priceRatioUpdateStartTime: Int

  """
  The protocol version on which the pool is deployed, 1, 2 or 3
  """
  protocolVersion: Int!

  """
  QuantAmmWeighted specific fields
  """
  quantAmmWeightedParams: QuantAmmWeightedParams

  """
  Data specific to gyro pools
  """
  root3Alpha: String

  """
  Data specific to gyro pools
  """
  s: String

  """
  Data specific to gyro pools
  """
  sqrtAlpha: String

  """
  Data specific to gyro pools
  """
  sqrtBeta: String

  """
  ReClamm: The fourth root price ratio at the start of an update
  """
  startFourthRootPriceRatio: BigDecimal

  """
  Account empowered to set static swap fees for a pool (when 0 on V2 swap fees are immutable, on V3 delegate to governance)
  """
  swapFeeManager: Bytes

  """
  The token symbol of the pool as per contract
  """
  symbol: String!

  """
  Data specific to gyro pools
  """
  tauAlphaX: String

  """
  Data specific to gyro pools
  """
  tauAlphaY: String

  """
  Data specific to gyro pools
  """
  tauBetaX: String

  """
  Data specific to gyro pools
  """
  tauBetaY: String

  """
  The pool type, such as weighted, stable, etc.
  """
  type: GqlPoolType!

  """
  Data specific to gyro pools
  """
  u: String

  """
  Data specific to gyro pools
  """
  v: String

  """
  The version of the pool type.
  """
  version: Int!

  """
  Data specific to gyro pools
  """
  w: String

  """
  Data specific to gyro pools
  """
  z: String
}

"""
All APRs for a pool
"""
type GqlPoolAprItem {
  """
  The APR value in % -> 0.2 = 20%
  """
  apr: Float!

  """
  The id of the APR item
  """
  id: ID!

  """
  The reward token address, if the APR originates from token emissions
  """
  rewardTokenAddress: String

  """
  The reward token symbol, if the APR originates from token emissions
  """
  rewardTokenSymbol: String

  """
  The title of the APR item, a human readable form
  """
  title: String!
    @deprecated(reason: "No replacement, should be built client side")

  """
  Specific type of this APR
  """
  type: GqlPoolAprItemType!
}

"""
Enum representing the different types of the APR in a pool.
"""
enum GqlPoolAprItemType {
  """
  APR that pools earns when BPT is staked on AURA.
  """
  AURA

  """
  Dynamic swap fee APR based on data from the last 24h
  """
  DYNAMIC_SWAP_FEE_24H

  """
  Represents the yield from an IB (Interest-Bearing) asset APR in a pool.
  """
  IB_YIELD

  """
  APR in a pool that can be earned through locking, i.e. veBAL
  """
  LOCKING

  """
  Reward APR in a pool from maBEETS emissions allocated by gauge votes. Emitted in BEETS.
  """
  MABEETS_EMISSIONS

  """
  Rewards distributed by merkl.xyz
  """
  MERKL

  """
  Represents if the APR items comes from a nested pool.
  """
  NESTED

  """
  APR calculated for QUANT-AMM pools based on performance measurements over a month
  """
  QUANT_AMM_UPLIFT

  """
  Staking reward APR in a pool from a reward token.
  """
  STAKING

  """
  APR boost that can be earned, i.e. via veBAL or maBEETS.
  """
  STAKING_BOOST

  """
  Cow AMM specific APR
  """
  SURPLUS @deprecated(reason: "Use SURPLUS_24H instead")

  """
  Surplus APR based on data from the last 7d
  """
  SURPLUS_7D

  """
  Surplus APR based on data from the last 24h
  """
  SURPLUS_24H

  """
  Surplus APR based on data from the last 30d
  """
  SURPLUS_30D

  """
  Represents the swap fee APR in a pool.
  """
  SWAP_FEE @deprecated(reason: "Use SWAP_FEE_24H instead")

  """
  Swap fee APR based on data from the last 7d
  """
  SWAP_FEE_7D

  """
  Swap fee APR based on data from the last 24h
  """
  SWAP_FEE_24H

  """
  Swap fee APR based on data from the last 30d
  """
  SWAP_FEE_30D

  """
  Reward APR in a pool from veBAL emissions allocated by gauge votes. Emitted in BAL.
  """
  VEBAL_EMISSIONS

  """
  APR that can be earned thourgh voting, i.e. gauge votes
  """
  VOTING
}

"""
The base type as returned by poolGetPool (specific pool query)
"""
interface GqlPoolBase {
  """
  The contract address of the pool.
  """
  address: Bytes!

  """
  List of categories assigned by the team based on external factors
  """
  categories: [GqlPoolFilterCategory]

  """
  The chain on which the pool is deployed
  """
  chain: GqlChain!

  """
  The timestamp the pool was created.
  """
  createTime: Int!

  """
  The decimals of the BPT, usually 18
  """
  decimals: Int!

  """
  Dynamic data such as token balances, swap fees or volume
  """
  dynamicData: GqlPoolDynamicData!

  """
  The factory contract address from which the pool was created.
  """
  factory: Bytes

  """
  Whether at least one token in this pool is considered an ERC4626 token and the buffer is allowed.
  """
  hasAnyAllowedBuffer: Boolean!

  """
  Whether at least one token in this pool is considered an ERC4626 token.
  """
  hasErc4626: Boolean!

  """
  Whether at least one token in a nested pool is considered an ERC4626 token.
  """
  hasNestedErc4626: Boolean!

  """
  Hook assigned to a pool
  """
  hook: GqlHook

  """
  The pool id. This is equal to the address for protocolVersion 3 pools
  """
  id: ID!

  """
  Liquidity management settings for v3 pools.
  """
  liquidityManagement: LiquidityManagement

  """
  The name of the pool as per contract
  """
  name: String!

  """
  The wallet address of the owner of the pool. Pool owners can set certain properties like swapFees or AMP.
  """
  owner: Bytes @deprecated(reason: "Use swapFeeManager instead")

  """
  Account empowered to pause/unpause the pool (or 0 to delegate to governance)
  """
  pauseManager: Bytes

  """
  Account empowered to set the pool creator fee percentage
  """
  poolCreator: Bytes

  """
  Returns pool tokens, including BPTs and nested pools and their pool tokens if there are any. Only one nested level deep.
  """
  poolTokens: [GqlPoolTokenDetail!]!

  """
  The protocol version on which the pool is deployed, 1, 2 or 3
  """
  protocolVersion: Int!

  """
  Staking options of this pool which emit additional rewards
  """
  staking: GqlPoolStaking

  """
  Account empowered to set static swap fees for a pool (when 0 on V2 swap fees are immutable, on V3 delegate to governance)
  """
  swapFeeManager: Bytes

  """
  The token symbol of the pool as per contract
  """
  symbol: String!

  """
  List of tags assigned by the team based on external factors
  """
  tags: [String]

  """
  The pool type, such as weighted, stable, etc.
  """
  type: GqlPoolType!

  """
  If a user address was provided in the query, the user balance is populated here
  """
  userBalance: GqlPoolUserBalance

  """
  The vault version on which the pool is deployed, 2 or 3
  """
  vaultVersion: Int! @deprecated(reason: "use protocolVersion instead")

  """
  The version of the pool type.
  """
  version: Int!
}

type GqlPoolComposableStable implements GqlPoolBase {
  address: Bytes!
  amp: BigInt!
  bptPriceRate: BigDecimal!
  categories: [GqlPoolFilterCategory]
  chain: GqlChain!
  createTime: Int!
  decimals: Int!
  dynamicData: GqlPoolDynamicData!
  factory: Bytes
  hasAnyAllowedBuffer: Boolean!
  hasErc4626: Boolean!
  hasNestedErc4626: Boolean!
  hook: GqlHook
  id: ID!
  liquidityManagement: LiquidityManagement
  name: String!

  """
  The wallet address of the owner of the pool. Pool owners can set certain properties like swapFees or AMP.
  """
  owner: Bytes @deprecated(reason: "Use swapFeeManager instead")

  """
  Account empowered to pause/unpause the pool (or 0 to delegate to governance)
  """
  pauseManager: Bytes

  """
  Account empowered to set the pool creator fee percentage
  """
  poolCreator: Bytes
  poolTokens: [GqlPoolTokenDetail!]!
  protocolVersion: Int!
  staking: GqlPoolStaking

  """
  Account empowered to set static swap fees for a pool (when 0 on V2 swap fees are immutable, on V3 delegate to governance)
  """
  swapFeeManager: Bytes
  symbol: String!
  tags: [String]
  type: GqlPoolType!
  userBalance: GqlPoolUserBalance
  vaultVersion: Int! @deprecated(reason: "use protocolVersion instead")
  version: Int!
}

type GqlPoolDynamicData {
  """
  Protocol and pool creator fees combined
  """
  aggregateSwapFee: BigDecimal!

  """
  Protocol and pool creator fees combined
  """
  aggregateYieldFee: BigDecimal!
  aprItems: [GqlPoolAprItem!]!
  fees24h: BigDecimal!
  fees24hAth: BigDecimal! @deprecated
  fees24hAthTimestamp: Int! @deprecated
  fees24hAtl: BigDecimal! @deprecated
  fees24hAtlTimestamp: Int! @deprecated
  fees48h: BigDecimal!
  holdersCount: BigInt!

  """
  True for bricked pools
  """
  isInRecoveryMode: Boolean!
  isPaused: Boolean!
  lifetimeSwapFees: BigDecimal!
  lifetimeVolume: BigDecimal!
  poolId: ID!
  protocolFees24h: BigDecimal!
  protocolFees48h: BigDecimal!
  protocolYieldCapture24h: BigDecimal!
  protocolYieldCapture48h: BigDecimal!
  sharePriceAth: BigDecimal! @deprecated
  sharePriceAthTimestamp: Int! @deprecated
  sharePriceAtl: BigDecimal! @deprecated
  sharePriceAtlTimestamp: Int! @deprecated

  """
  CowAmm specific, equivalent of swap fees
  """
  surplus24h: BigDecimal!

  """
  CowAmm specific, equivalent of swap fees
  """
  surplus48h: BigDecimal!

  """
  Disabled for bricked pools
  """
  swapEnabled: Boolean!
  swapFee: BigDecimal!
  swapsCount: BigInt! @deprecated
  totalLiquidity: BigDecimal!
  totalLiquidity24hAgo: BigDecimal!
  totalLiquidityAth: BigDecimal! @deprecated
  totalLiquidityAthTimestamp: Int! @deprecated
  totalLiquidityAtl: BigDecimal! @deprecated
  totalLiquidityAtlTimestamp: Int! @deprecated
  totalShares: BigDecimal!
  totalShares24hAgo: BigDecimal!
  totalSupply: BigDecimal!
  volume24h: BigDecimal!
  volume24hAth: BigDecimal! @deprecated
  volume24hAthTimestamp: Int! @deprecated
  volume24hAtl: BigDecimal! @deprecated
  volume24hAtlTimestamp: Int! @deprecated
  volume48h: BigDecimal!
  yieldCapture24h: BigDecimal!
  yieldCapture48h: BigDecimal!
}

type GqlPoolElement implements GqlPoolBase {
  address: Bytes!
  baseToken: Bytes!
  categories: [GqlPoolFilterCategory]
  chain: GqlChain!
  createTime: Int!
  decimals: Int!
  dynamicData: GqlPoolDynamicData!
  factory: Bytes
  hasAnyAllowedBuffer: Boolean!
  hasErc4626: Boolean!
  hasNestedErc4626: Boolean!
  hook: GqlHook
  id: ID!
  liquidityManagement: LiquidityManagement
  name: String!

  """
  The wallet address of the owner of the pool. Pool owners can set certain properties like swapFees or AMP.
  """
  owner: Bytes @deprecated(reason: "Use swapFeeManager instead")

  """
  Account empowered to pause/unpause the pool (or 0 to delegate to governance)
  """
  pauseManager: Bytes

  """
  Account empowered to set the pool creator fee percentage
  """
  poolCreator: Bytes
  poolTokens: [GqlPoolTokenDetail!]!
  principalToken: Bytes!
  protocolVersion: Int!
  staking: GqlPoolStaking

  """
  Account empowered to set static swap fees for a pool (when 0 on V2 swap fees are immutable, on V3 delegate to governance)
  """
  swapFeeManager: Bytes
  symbol: String!
  tags: [String]
  type: GqlPoolType!
  unitSeconds: BigInt!
  userBalance: GqlPoolUserBalance
  vaultVersion: Int! @deprecated(reason: "use protocolVersion instead")
  version: Int!
}

"""
Represents an event that occurs in a pool.
"""
interface GqlPoolEvent {
  """
  The block number of the event.
  """
  blockNumber: Int!

  """
  The block timestamp of the event.
  """
  blockTimestamp: Int!

  """
  The chain on which the event occurred.
  """
  chain: GqlChain!

  """
  The unique identifier of the event.
  """
  id: ID!

  """
  The log index of the event.
  """
  logIndex: Int!

  """
  The pool ID associated with the event.
  """
  poolId: String!

  """
  The sender of the event.
  """
  sender: String!

  """
  The timestamp of the event.
  """
  timestamp: Int!

  """
  The transaction hash of the event.
  """
  tx: String!

  """
  The type of the event.
  """
  type: GqlPoolEventType!

  """
  The user address associated with the event.
  """
  userAddress: String!

  """
  The USD value of this event.
  """
  valueUSD: Float!
}

type GqlPoolEventAmount {
  address: String!
  amount: String!
  valueUSD: Float!
}

enum GqlPoolEventType {
  ADD
  REMOVE
  SWAP
}

input GqlPoolEventsFilter {
  chainIn: [GqlChain]
  poolId: String
  type: GqlPoolEventType
  userAddress: String
}

type GqlPoolFeaturedPool {
  description: String!
  pool: GqlPoolBase!
  poolId: ID!
  primary: Boolean!
}

input GqlPoolFilter {
  chainIn: [GqlChain!]
  chainNotIn: [GqlChain!]
  createTime: GqlPoolTimePeriod
  idIn: [String!]
  idNotIn: [String!]
  minTvl: Float
  poolTypeIn: [GqlPoolType!]
  poolTypeNotIn: [GqlPoolType!]
  protocolVersionIn: [Int!]

  """
  For list of tags see: https://github.com/balancer/metadata/blob/main/pools/index.json
  Use uppercase
  """
  tagIn: [String!]

  """
  For list of tags see: https://github.com/balancer/metadata/blob/main/pools/index.json
  Use uppercase
  """
  tagNotIn: [String!]
  tokensIn: [String!]
  tokensNotIn: [String!]
  userAddress: String
}

enum GqlPoolFilterCategory {
  BLACK_LISTED
  INCENTIVIZED
  LRT
  POINTS
  POINTS_EIGENLAYER
  POINTS_GYRO
  POINTS_KELP
  POINTS_RENZO
  POINTS_SWELL
  SUPERFEST
}

type GqlPoolFixedPriceLBP implements GqlPoolBase {
  address: Bytes!
  categories: [GqlPoolFilterCategory]
  chain: GqlChain!
  createTime: Int!
  decimals: Int!
  description: String
  discord: String
  dynamicData: GqlPoolDynamicData!
  endTime: Int!
  factory: Bytes
  farcaster: String
  hasAnyAllowedBuffer: Boolean!
  hasErc4626: Boolean!
  hasNestedErc4626: Boolean!
  hook: GqlHook
  id: ID!
  lbpName: String
  lbpOwner: String!
  liquidityManagement: LiquidityManagement
  name: String!

  """
  The wallet address of the owner of the pool. Pool owners can set certain properties like swapFees or AMP.
  """
  owner: Bytes @deprecated(reason: "Use swapFeeManager instead")

  """
  Account empowered to pause/unpause the pool (or 0 to delegate to governance)
  """
  pauseManager: Bytes

  """
  Account empowered to set the pool creator fee percentage
  """
  poolCreator: Bytes
  poolTokens: [GqlPoolTokenDetail!]!
  projectToken: String!
  projectTokenIndex: Int!
  protocolVersion: Int!
  reserveToken: String!
  reserveTokenIndex: Int!

  """
  All tokens of the pool. If it is a nested pool, the nested pool is expanded with its own tokens again.
  """
  staking: GqlPoolStaking
  startTime: Int!

  """
  Account empowered to set static swap fees for a pool (when 0 on V2 swap fees are immutable, on V3 delegate to governance)
  """
  swapFeeManager: Bytes
  symbol: String!
  tags: [String]
  telegram: String
  topTrades: [GqlLBPTopTrade!]
  type: GqlPoolType!
  userBalance: GqlPoolUserBalance
  vaultVersion: Int! @deprecated(reason: "use protocolVersion instead")
  version: Int!
  website: String
  x: String
}

type GqlPoolFx implements GqlPoolBase {
  address: Bytes!
  alpha: String!
  beta: String!
  categories: [GqlPoolFilterCategory]
  chain: GqlChain!
  createTime: Int!
  decimals: Int!
  delta: String!
  dynamicData: GqlPoolDynamicData!
  epsilon: String!
  factory: Bytes
  hasAnyAllowedBuffer: Boolean!
  hasErc4626: Boolean!
  hasNestedErc4626: Boolean!
  hook: GqlHook
  id: ID!
  lambda: String!
  liquidityManagement: LiquidityManagement
  name: String!

  """
  The wallet address of the owner of the pool. Pool owners can set certain properties like swapFees or AMP.
  """
  owner: Bytes @deprecated(reason: "Use swapFeeManager instead")

  """
  Account empowered to pause/unpause the pool (or 0 to delegate to governance)
  """
  pauseManager: Bytes

  """
  Account empowered to set the pool creator fee percentage
  """
  poolCreator: Bytes
  poolTokens: [GqlPoolTokenDetail!]!
  protocolVersion: Int!
  staking: GqlPoolStaking

  """
  Account empowered to set static swap fees for a pool (when 0 on V2 swap fees are immutable, on V3 delegate to governance)
  """
  swapFeeManager: Bytes
  symbol: String!
  tags: [String]
  type: GqlPoolType!
  userBalance: GqlPoolUserBalance
  vaultVersion: Int! @deprecated(reason: "use protocolVersion instead")
  version: Int!
}

type GqlPoolGyro implements GqlPoolBase {
  address: Bytes!
  alpha: String!
  beta: String!
  c: String!
  categories: [GqlPoolFilterCategory]
  chain: GqlChain!
  createTime: Int!
  dSq: String!
  decimals: Int!
  dynamicData: GqlPoolDynamicData!
  factory: Bytes
  hasAnyAllowedBuffer: Boolean!
  hasErc4626: Boolean!
  hasNestedErc4626: Boolean!
  hook: GqlHook
  id: ID!
  lambda: String!
  liquidityManagement: LiquidityManagement
  name: String!

  """
  The wallet address of the owner of the pool. Pool owners can set certain properties like swapFees or AMP.
  """
  owner: Bytes @deprecated(reason: "Use swapFeeManager instead")

  """
  Account empowered to pause/unpause the pool (or 0 to delegate to governance)
  """
  pauseManager: Bytes

  """
  Account empowered to set the pool creator fee percentage
  """
  poolCreator: Bytes
  poolTokens: [GqlPoolTokenDetail!]!
  protocolVersion: Int!
  root3Alpha: String!
  s: String!
  sqrtAlpha: String!
  sqrtBeta: String!
  staking: GqlPoolStaking

  """
  Account empowered to set static swap fees for a pool (when 0 on V2 swap fees are immutable, on V3 delegate to governance)
  """
  swapFeeManager: Bytes
  symbol: String!
  tags: [String]
  tauAlphaX: String!
  tauAlphaY: String!
  tauBetaX: String!
  tauBetaY: String!
  type: GqlPoolType!
  u: String!
  userBalance: GqlPoolUserBalance
  v: String!
  vaultVersion: Int! @deprecated(reason: "use protocolVersion instead")
  version: Int!
  w: String!
  z: String!
}

type GqlPoolLiquidityBootstrapping implements GqlPoolBase {
  address: Bytes!
  categories: [GqlPoolFilterCategory]
  chain: GqlChain!
  createTime: Int!
  decimals: Int!
  dynamicData: GqlPoolDynamicData!
  factory: Bytes
  hasAnyAllowedBuffer: Boolean!
  hasErc4626: Boolean!
  hasNestedErc4626: Boolean!
  hook: GqlHook
  id: ID!
  liquidityManagement: LiquidityManagement
  name: String!

  """
  The wallet address of the owner of the pool. Pool owners can set certain properties like swapFees or AMP.
  """
  owner: Bytes @deprecated(reason: "Use swapFeeManager instead")

  """
  Account empowered to pause/unpause the pool (or 0 to delegate to governance)
  """
  pauseManager: Bytes

  """
  Account empowered to set the pool creator fee percentage
  """
  poolCreator: Bytes
  poolTokens: [GqlPoolTokenDetail!]!
  protocolVersion: Int!
  staking: GqlPoolStaking

  """
  Account empowered to set static swap fees for a pool (when 0 on V2 swap fees are immutable, on V3 delegate to governance)
  """
  swapFeeManager: Bytes
  symbol: String!
  tags: [String]
  type: GqlPoolType!
  userBalance: GqlPoolUserBalance
  vaultVersion: Int! @deprecated(reason: "use protocolVersion instead")
  version: Int!
}

type GqlPoolLiquidityBootstrappingV3 implements GqlPoolBase {
  address: Bytes!
  categories: [GqlPoolFilterCategory]
  chain: GqlChain!
  createTime: Int!
  decimals: Int!
  description: String
  discord: String
  dynamicData: GqlPoolDynamicData!
  endTime: Int!
  factory: Bytes
  farcaster: String
  hasAnyAllowedBuffer: Boolean!
  hasErc4626: Boolean!
  hasNestedErc4626: Boolean!
  hook: GqlHook
  id: ID!
  isProjectTokenSwapInBlocked: Boolean!
  isSeedless: Boolean!
  lbpName: String
  lbpOwner: String!
  liquidityManagement: LiquidityManagement
  name: String!

  """
  The wallet address of the owner of the pool. Pool owners can set certain properties like swapFees or AMP.
  """
  owner: Bytes @deprecated(reason: "Use swapFeeManager instead")

  """
  Account empowered to pause/unpause the pool (or 0 to delegate to governance)
  """
  pauseManager: Bytes

  """
  Account empowered to set the pool creator fee percentage
  """
  poolCreator: Bytes
  poolTokens: [GqlPoolTokenDetail!]!
  projectToken: String!
  projectTokenEndWeight: Float!
  projectTokenIndex: Int!
  projectTokenStartWeight: Float!
  protocolVersion: Int!
  reserveToken: String!
  reserveTokenEndWeight: Float!
  reserveTokenIndex: Int!
  reserveTokenStartWeight: Float!

  """
  All tokens of the pool. If it is a nested pool, the nested pool is expanded with its own tokens again.
  """
  staking: GqlPoolStaking
  startTime: Int!

  """
  Account empowered to set static swap fees for a pool (when 0 on V2 swap fees are immutable, on V3 delegate to governance)
  """
  swapFeeManager: Bytes
  symbol: String!
  tags: [String]
  telegram: String
  topTrades: [GqlLBPTopTrade!]
  type: GqlPoolType!
  userBalance: GqlPoolUserBalance
  vaultVersion: Int! @deprecated(reason: "use protocolVersion instead")
  version: Int!
  website: String
  x: String
}

type GqlPoolMetaStable implements GqlPoolBase {
  address: Bytes!
  amp: BigInt!
  categories: [GqlPoolFilterCategory]
  chain: GqlChain!
  createTime: Int!
  decimals: Int!
  dynamicData: GqlPoolDynamicData!
  factory: Bytes
  hasAnyAllowedBuffer: Boolean!
  hasErc4626: Boolean!
  hasNestedErc4626: Boolean!
  hook: GqlHook
  id: ID!
  liquidityManagement: LiquidityManagement
  name: String!

  """
  The wallet address of the owner of the pool. Pool owners can set certain properties like swapFees or AMP.
  """
  owner: Bytes @deprecated(reason: "Use swapFeeManager instead")

  """
  Account empowered to pause/unpause the pool (or 0 to delegate to governance)
  """
  pauseManager: Bytes

  """
  Account empowered to set the pool creator fee percentage
  """
  poolCreator: Bytes
  poolTokens: [GqlPoolTokenDetail!]!
  protocolVersion: Int!
  staking: GqlPoolStaking

  """
  Account empowered to set static swap fees for a pool (when 0 on V2 swap fees are immutable, on V3 delegate to governance)
  """
  swapFeeManager: Bytes
  symbol: String!
  tags: [String]
  type: GqlPoolType!
  userBalance: GqlPoolUserBalance
  vaultVersion: Int! @deprecated(reason: "use protocolVersion instead")
  version: Int!
}

"""
The pool schema returned for poolGetPools (pool list query)
"""
type GqlPoolMinimal {
  """
  The contract address of the pool.
  """
  address: Bytes!

  """
  List of categories assigned by the team based on external factors
  """
  categories: [GqlPoolFilterCategory]

  """
  The chain on which the pool is deployed
  """
  chain: GqlChain!

  """
  The timestamp the pool was created.
  """
  createTime: Int!

  """
  The decimals of the BPT, usually 18
  """
  decimals: Int!

  """
  Dynamic data such as token balances, swap fees or volume
  """
  dynamicData: GqlPoolDynamicData!

  """
  The factory contract address from which the pool was created.
  """
  factory: Bytes

  """
  Whether at least one token in this pool is considered an ERC4626 token and the buffer is allowed.
  """
  hasAnyAllowedBuffer: Boolean!

  """
  Whether at least one token in this pool is considered an ERC4626 token.
  """
  hasErc4626: Boolean!

  """
  Whether at least one token in a nested pool is considered an ERC4626 token.
  """
  hasNestedErc4626: Boolean!

  """
  Hook assigned to a pool
  """
  hook: GqlHook

  """
  The pool id. This is equal to the address for protocolVersion 3 pools
  """
  id: ID!

  """
  Pool is receiving rewards when liquidity tokens are staked
  """
  incentivized: Boolean!

  """
  LBP specific params for v3 pools only.
  """
  lbpParams: LiquidityBootstrappingPoolV3Params

  """
  Liquidity management settings for v3 pools.
  """
  liquidityManagement: LiquidityManagement

  """
  The name of the pool as per contract
  """
  name: String!

  """
  The wallet address of the owner of the pool. Pool owners can set certain properties like swapFees or AMP.
  """
  owner: Bytes @deprecated(reason: "Use swapFeeManager instead")

  """
  Account empowered to pause/unpause the pool (or 0 to delegate to governance)
  """
  pauseManager: Bytes

  """
  Account empowered to set the pool creator fee percentage
  """
  poolCreator: Bytes

  """
  Returns all pool tokens, including BPTs and nested pools if there are any. Only one nested level deep.
  """
  poolTokens: [GqlPoolTokenDetail!]!

  """
  The protocol version on which the pool is deployed, 1, 2 or 3
  """
  protocolVersion: Int!

  """
  Staking options of this pool which emit additional rewards
  """
  staking: GqlPoolStaking

  """
  Account empowered to set static swap fees for a pool (when 0 on V2 swap fees are immutable, on V3 delegate to governance)
  """
  swapFeeManager: Bytes

  """
  The token symbol of the pool as per contract
  """
  symbol: String!

  """
  List of tags assigned by the team based on external factors
  """
  tags: [String]

  """
  The pool type, such as weighted, stable, etc.
  """
  type: GqlPoolType!

  """
  If a user address was provided in the query, the user balance is populated here
  """
  userBalance: GqlPoolUserBalance

  """
  The vault version on which the pool is deployed, 2 or 3
  """
  vaultVersion: Int! @deprecated(reason: "use protocolVersion instead")

  """
  The version of the pool type.
  """
  version: Int!
}

"""
Result of the poolReloadPools mutation
"""
type GqlPoolMutationResult {
  """
  The chain that was reloaded.
  """
  chain: GqlChain!

  """
  The error message
  """
  error: String

  """
  Whether it was successful or not.
  """
  success: Boolean!

  """
  The type of pools that were reloaded.
  """
  type: String!
}

enum GqlPoolOrderBy {
  apr
  fees24h
  totalLiquidity
  totalShares
  userbalanceUsd
  volume24h
}

enum GqlPoolOrderDirection {
  asc
  desc
}

type GqlPoolQuantAmmWeighted implements GqlPoolBase {
  address: Bytes!
  categories: [GqlPoolFilterCategory]
  chain: GqlChain!
  createTime: Int!
  decimals: Int!
  dynamicData: GqlPoolDynamicData!
  factory: Bytes
  hasAnyAllowedBuffer: Boolean!
  hasErc4626: Boolean!
  hasNestedErc4626: Boolean!
  hook: GqlHook
  id: ID!
  liquidityManagement: LiquidityManagement
  name: String!

  """
  The wallet address of the owner of the pool. Pool owners can set certain properties like swapFees or AMP.
  """
  owner: Bytes @deprecated(reason: "Use swapFeeManager instead")

  """
  Account empowered to pause/unpause the pool (or 0 to delegate to governance)
  """
  pauseManager: Bytes

  """
  Account empowered to set the pool creator fee percentage
  """
  poolCreator: Bytes
  poolTokens: [GqlPoolTokenDetail!]!
  protocolVersion: Int!
  quantAmmWeightedParams: QuantAmmWeightedParams
  staking: GqlPoolStaking

  """
  Account empowered to set static swap fees for a pool (when 0 on V2 swap fees are immutable, on V3 delegate to governance)
  """
  swapFeeManager: Bytes
  symbol: String!
  tags: [String]
  type: GqlPoolType!
  userBalance: GqlPoolUserBalance
  vaultVersion: Int! @deprecated(reason: "use protocolVersion instead")
  version: Int!
  weightSnapshots: [QuantAmmWeightSnapshot!]
}

type GqlPoolReClamm implements GqlPoolBase {
  address: Bytes!
  categories: [GqlPoolFilterCategory]

  """
  The centeredness margin of the pool
  """
  centerednessMargin: BigDecimal!
  chain: GqlChain!
  createTime: Int!

  """
  The current fourth root price ratio, an interpolation of the price ratio state
  """
  currentFourthRootPriceRatio: BigDecimal!

  """
  Represents how fast the pool can move the virtual balances per day
  """
  dailyPriceShiftBase: BigDecimal!
  decimals: Int!
  dynamicData: GqlPoolDynamicData!

  """
  The fourth root price ratio at the end of an update
  """
  endFourthRootPriceRatio: BigDecimal!
  factory: Bytes
  hasAnyAllowedBuffer: Boolean!
  hasErc4626: Boolean!
  hasNestedErc4626: Boolean!
  hook: GqlHook
  id: ID!

  """
  The timestamp of the last user interaction
  """
  lastTimestamp: Int!

  """
  The last virtual balances of the pool
  """
  lastVirtualBalances: [BigDecimal!]!
  liquidityManagement: LiquidityManagement
  name: String!

  """
  The wallet address of the owner of the pool. Pool owners can set certain properties like swapFees or AMP.
  """
  owner: Bytes @deprecated(reason: "Use swapFeeManager instead")

  """
  Account empowered to pause/unpause the pool (or 0 to delegate to governance)
  """
  pauseManager: Bytes

  """
  Account empowered to set the pool creator fee percentage
  """
  poolCreator: Bytes
  poolTokens: [GqlPoolTokenDetail!]!

  """
  The timestamp when the update ends
  """
  priceRatioUpdateEndTime: Int!

  """
  The timestamp when the update begins
  """
  priceRatioUpdateStartTime: Int!
  protocolVersion: Int!
  staking: GqlPoolStaking

  """
  The fourth root price ratio at the start of an update
  """
  startFourthRootPriceRatio: BigDecimal!

  """
  Account empowered to set static swap fees for a pool (when 0 on V2 swap fees are immutable, on V3 delegate to governance)
  """
  swapFeeManager: Bytes
  symbol: String!
  tags: [String]
  type: GqlPoolType!
  userBalance: GqlPoolUserBalance
  vaultVersion: Int! @deprecated(reason: "use protocolVersion instead")
  version: Int!
}

type GqlPoolSnapshot {
  amounts: [String!]!
  chain: GqlChain!
  fees24h: String!
  holdersCount: String! @deprecated
  id: ID!
  poolId: String!
  sharePrice: String!
  surplus24h: String!
  swapsCount: String!
  timestamp: Int!
  totalLiquidity: String!
  totalShares: String!
  totalSurplus: String! @deprecated
  totalSwapFee: String! @deprecated
  totalSwapVolume: String! @deprecated
  volume24h: String!
}

enum GqlPoolSnapshotDataRange {
  ALL_TIME
  NINETY_DAYS
  ONE_HUNDRED_EIGHTY_DAYS
  ONE_YEAR
  THIRTY_DAYS
}

type GqlPoolStable implements GqlPoolBase {
  address: Bytes!
  amp: BigInt!
  bptPriceRate: BigDecimal!
  categories: [GqlPoolFilterCategory]
  chain: GqlChain!
  createTime: Int!
  decimals: Int!
  dynamicData: GqlPoolDynamicData!
  factory: Bytes
  hasAnyAllowedBuffer: Boolean!
  hasErc4626: Boolean!
  hasNestedErc4626: Boolean!
  hook: GqlHook
  id: ID!
  liquidityManagement: LiquidityManagement
  name: String!

  """
  The wallet address of the owner of the pool. Pool owners can set certain properties like swapFees or AMP.
  """
  owner: Bytes @deprecated(reason: "Use swapFeeManager instead")

  """
  Account empowered to pause/unpause the pool (or 0 to delegate to governance)
  """
  pauseManager: Bytes

  """
  Account empowered to set the pool creator fee percentage
  """
  poolCreator: Bytes
  poolTokens: [GqlPoolTokenDetail!]!
  protocolVersion: Int!
  staking: GqlPoolStaking

  """
  Account empowered to set static swap fees for a pool (when 0 on V2 swap fees are immutable, on V3 delegate to governance)
  """
  swapFeeManager: Bytes
  symbol: String!
  tags: [String]
  type: GqlPoolType!
  userBalance: GqlPoolUserBalance
  vaultVersion: Int! @deprecated(reason: "use protocolVersion instead")
  version: Int!
}

type GqlPoolStaking {
  address: String!
  aura: GqlPoolStakingAura
  chain: GqlChain!
  farm: GqlPoolStakingMasterChefFarm
  gauge: GqlPoolStakingGauge
  id: ID!
  reliquary: GqlPoolStakingReliquaryFarm
  type: GqlPoolStakingType!
  vebal: GqlPoolStakingVebal
}

type GqlPoolStakingAura {
  apr: Float!
  auraPoolAddress: String!
  auraPoolId: String!
  id: ID!
  isShutdown: Boolean!
}

type GqlPoolStakingFarmRewarder {
  address: String!
  id: ID!
  rewardPerSecond: String!
  tokenAddress: String!
}

type GqlPoolStakingGauge {
  gaugeAddress: String!
  id: ID!
  otherGauges: [GqlPoolStakingOtherGauge!]
  rewards: [GqlPoolStakingGaugeReward!]!
  status: GqlPoolStakingGaugeStatus!
  version: Int!
  workingSupply: String!
}

type GqlPoolStakingGaugeReward {
  id: ID!
  rewardPerSecond: String!
  tokenAddress: String!
}

enum GqlPoolStakingGaugeStatus {
  ACTIVE
  KILLED
  PREFERRED
}

type GqlPoolStakingMasterChefFarm {
  beetsPerBlock: String!
  id: ID!
  rewarders: [GqlPoolStakingFarmRewarder!]
}

type GqlPoolStakingOtherGauge {
  gaugeAddress: String!
  id: ID!
  rewards: [GqlPoolStakingGaugeReward!]!
  status: GqlPoolStakingGaugeStatus!
  version: Int!
}

type GqlPoolStakingReliquaryFarm {
  beetsPerSecond: String!
  id: ID!
  levels: [GqlPoolStakingReliquaryFarmLevel!]
  totalBalance: String!
  totalWeightedBalance: String!
}

type GqlPoolStakingReliquaryFarmLevel {
  allocationPoints: Int!
  apr: BigDecimal!
  balance: BigDecimal!
  id: ID!
  level: Int!
  requiredMaturity: Int!
}

enum GqlPoolStakingType {
  AURA
  FRESH_BEETS
  GAUGE
  MASTER_CHEF
  RELIQUARY
  VEBAL
}

type GqlPoolStakingVebal {
  id: ID!
  vebalAddress: String!
}

"""
Represents an event that occurs when a swap is made in a pool using the CowAmm protocol.
"""
type GqlPoolSwapEventCowAmm implements GqlPoolEvent {
  """
  The block number of the event.
  """
  blockNumber: Int!

  """
  The block timestamp of the event.
  """
  blockTimestamp: Int!

  """
  The chain on which the event occurred.
  """
  chain: GqlChain!

  """
  The fee that this swap generated.
  """
  fee: GqlPoolEventAmount!

  """
  The unique identifier of the event.
  """
  id: ID!

  """
  The log index of the event.
  """
  logIndex: Int!

  """
  The pool ID associated with the event.
  """
  poolId: String!

  """
  The sender of the event.
  """
  sender: String!

  """
  The surplus generated by the swap.
  """
  surplus: GqlPoolEventAmount!

  """
  The timestamp of the event.
  """
  timestamp: Int!

  """
  The token that was swapped in the event.
  """
  tokenIn: GqlPoolEventAmount!

  """
  The token that was swapped out in the event.
  """
  tokenOut: GqlPoolEventAmount!

  """
  The transaction hash of the event.
  """
  tx: String!

  """
  The type of the event.
  """
  type: GqlPoolEventType!

  """
  The user address associated with the event.
  """
  userAddress: String!

  """
  The value of the event in USD.
  """
  valueUSD: Float!
}

"""
Represents an event that occurs when a swap is made in a pool.
"""
type GqlPoolSwapEventV3 implements GqlPoolEvent {
  """
  The block number of the event.
  """
  blockNumber: Int!

  """
  The block timestamp of the event.
  """
  blockTimestamp: Int!

  """
  The chain on which the event occurred.
  """
  chain: GqlChain!

  """
  The fee that this swap generated.
  """
  fee: GqlPoolEventAmount!

  """
  The unique identifier of the event.
  """
  id: ID!

  """
  The log index of the event.
  """
  logIndex: Int!

  """
  The pool ID associated with the event.
  """
  poolId: String!

  """
  The sender of the event.
  """
  sender: String!

  """
  The timestamp of the event.
  """
  timestamp: Int!

  """
  The token that was swapped in the event.
  """
  tokenIn: GqlPoolEventAmount!

  """
  The token that was swapped out in the event.
  """
  tokenOut: GqlPoolEventAmount!

  """
  The transaction hash of the event.
  """
  tx: String!

  """
  The type of the event.
  """
  type: GqlPoolEventType!

  """
  The user address associated with the event.
  """
  userAddress: String!

  """
  The value of the event in USD.
  """
  valueUSD: Float!
}

input GqlPoolTimePeriod {
  gt: Int
  lt: Int
}

"""
All info on the pool token. It will also include the nested pool if the token is a BPT. It will only support 1 level of nesting.
A second (unsupported) level of nesting is shown by having hasNestedPool = true but nestedPool = null.
"""
type GqlPoolTokenDetail {
  """
  Address of the pool token.
  """
  address: String!

  """
  Balance of the pool token inside the pool.
  """
  balance: BigDecimal!

  """
  USD Balance of the pool token.
  """
  balanceUSD: BigDecimal!

  """
  If it is an ERC4626 token, this defines whether we can use wrap/unwrap through the buffer in swap paths for this token.
  """
  canUseBufferForSwaps: Boolean
  chain: GqlChain
  chainId: Int

  """
  Coingecko ID
  """
  coingeckoId: String

  """
  Decimals of the pool token.
  """
  decimals: Int!

  """
  The ERC4626 review data for the token
  """
  erc4626ReviewData: Erc4626ReviewData

  """
  Indicates whether this token is a BPT and therefor has a nested pool.
  """
  hasNestedPool: Boolean!

  """
  Id of the token. A combination of pool id and token address.
  """
  id: ID!

  """
  Index of the pool token in the pool as returned by the vault.
  """
  index: Int!

  """
  Whether the token is in the allow list.
  """
  isAllowed: Boolean!

  """
  If it is an ERC4626 token, this defines whether we allow it to use the buffer for pool operations.
  """
  isBufferAllowed: Boolean!
    @deprecated(
      reason: "Use useUnderlyingForAddRemove and useWrappedForAddRemove instead"
    )

  """
  Whether the token is considered an ERC4626 token.
  """
  isErc4626: Boolean!

  """
  Whether the token is exempted from taking a protocol yield fee.
  """
  isExemptFromProtocolYieldFee: Boolean!

  """
  Token logo
  """
  logoURI: String

  """
  If it is an ERC4626 token, this  defines how much can be deposited into the ERC4626 vault.
  """
  maxDeposit: String

  """
  If it is an ERC4626 token, this  defines how much can be withdrawn from the ERC4626 vault.
  """
  maxWithdraw: String

  """
  Name of the pool token.
  """
  name: String!

  """
  Additional data for the nested pool if the token is a BPT. Null otherwise.
  """
  nestedPool: GqlNestedPool

  """
  If it is an appreciating token, it shows the current price rate. 1 otherwise.
  """
  priceRate: BigDecimal!

  """
  The address of the price rate provider.
  """
  priceRateProvider: String

  """
  Additional data for the price rate provider, such as reviews or warnings.
  """
  priceRateProviderData: GqlPriceRateProviderData

  """
  The priority of the token, can be used for sorting.
  """
  priority: Int @deprecated(reason: "Unused")

  """
  Conversion factor used to adjust for token decimals for uniform precision in calculations. V3 only.
  """
  scalingFactor: BigDecimal

  """
  Symbol of the pool token.
  """
  symbol: String!

  """
  Is the token tradable
  """
  tradable: Boolean @deprecated(reason: "Unused")

  """
  If it is an ERC4626, this will be the underlying token if present in the API.
  """
  underlyingToken: GqlToken

  """
  If it is an ERC4626 token, this defines whether we allow underlying tokens to be used for add/remove operations.
  """
  useUnderlyingForAddRemove: Boolean

  """
  If it is an ERC4626 token, this defines whether we allow the wrapped tokens to be used for add/remove operations.
  """
  useWrappedForAddRemove: Boolean

  """
  The weight of the token in the pool if it is a weighted pool, null otherwise
  """
  weight: BigDecimal
}

"""
Supported pool types
"""
enum GqlPoolType {
  COMPOSABLE_STABLE
  COW_AMM
  ELEMENT
  FIXED_LBP
  FX
  GYRO
  GYRO3
  GYROE
  INVESTMENT
  LIQUIDITY_BOOTSTRAPPING
  META_STABLE
  PHANTOM_STABLE
  QUANT_AMM_WEIGHTED
  RECLAMM
  STABLE
  UNKNOWN
  WEIGHTED
}

union GqlPoolUnion =
  | GqlPoolComposableStable
  | GqlPoolElement
  | GqlPoolFixedPriceLBP
  | GqlPoolFx
  | GqlPoolGyro
  | GqlPoolLiquidityBootstrapping
  | GqlPoolLiquidityBootstrappingV3
  | GqlPoolMetaStable
  | GqlPoolQuantAmmWeighted
  | GqlPoolReClamm
  | GqlPoolStable
  | GqlPoolWeighted

"""
If a user address was provided in the query, the user balance is populated here
"""
type GqlPoolUserBalance {
  """
  The staked BPT balances of the user.
  """
  stakedBalances: [GqlUserStakedBalance!]!

  """
  Total balance (wallet + staked) as float
  """
  totalBalance: AmountHumanReadable!

  """
  Total balance (wallet + staked) in USD as float
  """
  totalBalanceUsd: Float!

  """
  The wallet balance (BPT in wallet) as float.
  """
  walletBalance: AmountHumanReadable!

  """
  The wallet balance (BPT in wallet) in USD as float.
  """
  walletBalanceUsd: Float!
}

type GqlPoolWeighted implements GqlPoolBase {
  address: Bytes!
  categories: [GqlPoolFilterCategory]
  chain: GqlChain!
  createTime: Int!
  decimals: Int!
  dynamicData: GqlPoolDynamicData!
  factory: Bytes
  hasAnyAllowedBuffer: Boolean!
  hasErc4626: Boolean!
  hasNestedErc4626: Boolean!
  hook: GqlHook
  id: ID!
  liquidityManagement: LiquidityManagement
  name: String!

  """
  The wallet address of the owner of the pool. Pool owners can set certain properties like swapFees or AMP.
  """
  owner: Bytes @deprecated(reason: "Use swapFeeManager instead")

  """
  Account empowered to pause/unpause the pool (or 0 to delegate to governance)
  """
  pauseManager: Bytes

  """
  Account empowered to set the pool creator fee percentage
  """
  poolCreator: Bytes
  poolTokens: [GqlPoolTokenDetail!]!
  protocolVersion: Int!
  staking: GqlPoolStaking

  """
  Account empowered to set static swap fees for a pool (when 0 on V2 swap fees are immutable, on V3 delegate to governance)
  """
  swapFeeManager: Bytes
  symbol: String!
  tags: [String]
  type: GqlPoolType!
  userBalance: GqlPoolUserBalance
  vaultVersion: Int! @deprecated(reason: "use protocolVersion instead")
  version: Int!
}

"""
Returns the price impact of the path. If there is an error in the price impact calculation, priceImpact will be undefined but the error string is populated.
"""
type GqlPriceImpact {
  """
  If priceImpact cant be calculated and is returned as undefined, the error string will be populated.
  """
  error: String

  """
  Price impact in percent 0.01 -> 0.01%; undefined if an error happened.
  """
  priceImpact: AmountHumanReadable
}

"""
Represents the data of a price rate provider
"""
type GqlPriceRateProviderData {
  """
  The address of the price rate provider
  """
  address: String!

  """
  The factory used to create the price rate provider, if applicable
  """
  factory: String

  """
  The name of the price rate provider
  """
  name: String

  """
  The filename of the review of the price rate provider
  """
  reviewFile: String

  """
  Indicates if the price rate provider has been reviewed
  """
  reviewed: Boolean!

  """
  A summary of the price rate provider, usually just says safe or unsafe
  """
  summary: String

  """
  Upgradeable components of the price rate provider
  """
  upgradeableComponents: [GqlPriceRateProviderUpgradeableComponent]

  """
  Warnings associated with the price rate provider
  """
  warnings: [String!]
}

"""
Represents an upgradeable component of a price rate provider
"""
type GqlPriceRateProviderUpgradeableComponent {
  """
  The entry point / proxy of the upgradeable component
  """
  entryPoint: String!

  """
  Indicates if the implementation of the component has been reviewed
  """
  implementationReviewed: String!
}

type GqlProtocolMetricsAggregated {
  chains: [GqlProtocolMetricsChain!]!
  numLiquidityProviders: BigInt!
  poolCount: BigInt!
  surplus24h: BigDecimal!
  swapFee24h: BigDecimal!
  swapVolume24h: BigDecimal!
  totalLiquidity: BigDecimal!
  totalSwapFee: BigDecimal! @deprecated(reason: "No replacement")
  totalSwapVolume: BigDecimal! @deprecated(reason: "No replacement")
  yieldCapture24h: BigDecimal!
}

type GqlProtocolMetricsChain {
  chainId: String!
  numLiquidityProviders: BigInt!
  poolCount: BigInt!
  surplus24h: BigDecimal!
  swapFee24h: BigDecimal!
  swapVolume24h: BigDecimal!
  totalLiquidity: BigDecimal!
  totalSwapFee: BigDecimal! @deprecated(reason: "No replacement")
  totalSwapVolume: BigDecimal! @deprecated(reason: "No replacement")
  yieldCapture24h: BigDecimal!
}

type GqlRelicSnapshot {
  balance: String!
  entryTimestamp: Int!
  farmId: String!
  level: Int!
  relicId: Int!
}

type GqlReliquaryFarmLevelSnapshot {
  balance: String!
  id: ID!
  level: String!
}

type GqlReliquaryFarmSnapshot {
  dailyDeposited: String!
  dailyWithdrawn: String!
  farmId: String!
  id: ID!
  levelBalances: [GqlReliquaryFarmLevelSnapshot!]!
  relicCount: String!
  timestamp: Int!
  totalBalance: String!
  totalLiquidity: String!
  userCount: String!
}

type GqlSorCallData {
  """
  The call data that needs to be sent to the RPC
  """
  callData: String!

  """
  Maximum amount to be sent for exact out orders
  """
  maxAmountInRaw: String

  """
  Minimum amount received for exact in orders
  """
  minAmountOutRaw: String

  """
  The target contract to send the call data to
  """
  to: String!

  """
  Value in ETH that needs to be sent for native swaps
  """
  value: BigDecimal!
}

"""
The swap paths for a swap
"""
type GqlSorGetSwapPaths {
  """
  Transaction data that can be posted to an RPC to execute the swap.
  """
  callData: GqlSorCallData
    @deprecated(
      reason: "Use Balancer SDK to build swap callData from SOR response"
    )

  """
  The price of tokenOut in tokenIn.
  """
  effectivePrice: AmountHumanReadable!

  """
  The price of tokenIn in tokenOut.
  """
  effectivePriceReversed: AmountHumanReadable!

  """
  The found paths as needed as input for the b-sdk to execute the swap
  """
  paths: [GqlSorPath!]!

  """
  Price impact of the path
  """
  priceImpact: GqlPriceImpact!

  """
  The version of the protocol these paths are from
  """
  protocolVersion: Int!

  """
  The return amount in human form. Return amount is either tokenOutAmount (if swapType is exactIn) or tokenInAmount (if swapType is exactOut)
  """
  returnAmount: AmountHumanReadable!

  """
  The return amount in a raw form
  """
  returnAmountRaw: BigDecimal!

  """
  The swap routes including pool information. Used to display by the UI
  """
  routes: [GqlSorSwapRoute!]!

  """
  The swap amount in human form. Swap amount is either tokenInAmount (if swapType is exactIn) or tokenOutAmount (if swapType is exactOut)
  """
  swapAmount: AmountHumanReadable!

  """
  The swap amount in a raw form
  """
  swapAmountRaw: BigDecimal!

  """
  The swapType that was provided, exact_in vs exact_out (givenIn vs givenOut)
  """
  swapType: GqlSorSwapType!

  """
  Swaps as needed for the vault swap input to execute the swap
  """
  swaps: [GqlSorSwap!]!

  """
  All token addresses (or assets) as needed for the vault swap input to execute the swap
  """
  tokenAddresses: [String!]!

  """
  The token address of the tokenIn provided
  """
  tokenIn: String!

  """
  The amount of tokenIn in human form
  """
  tokenInAmount: AmountHumanReadable!

  """
  The token address of the tokenOut provided
  """
  tokenOut: String!

  """
  The amount of tokenOut in human form
  """
  tokenOutAmount: AmountHumanReadable!

  """
  The version of the vault these paths are from
  """
  vaultVersion: Int! @deprecated(reason: "Use protocolVersion instead")
}

"""
A path of a swap. A swap can have multiple paths. Used as input to execute the swap via b-sdk
"""
type GqlSorPath {
  """
  Input amount of this path in scaled form
  """
  inputAmountRaw: String!

  """
  A sorted list of booleans that indicate if the respective pool is a buffer
  """
  isBuffer: [Boolean!]!

  """
  Output amount of this path in scaled form
  """
  outputAmountRaw: String!

  """
  A sorted list of pool ids that are used in this path
  """
  pools: [String!]!

  """
  The version of the protocol these paths are from
  """
  protocolVersion: Int!

  """
  A sorted list of tokens that are ussed in this path
  """
  tokens: [Token!]!

  """
  Vault version of this path.
  """
  vaultVersion: Int! @deprecated(reason: "Use protocolVersion instead")
}

"""
A single swap step as used for input to the vault to execute a swap
"""
type GqlSorSwap {
  """
  Amount to be swapped in this step. 0 for chained swap.
  """
  amount: String!

  """
  Index of the asset used in the tokenAddress array.
  """
  assetInIndex: Int!

  """
  Index of the asset used in the tokenAddress array.
  """
  assetOutIndex: Int!

  """
  Pool id used in this swap step
  """
  poolId: String!

  """
  UserData used in this swap, generally uses defaults.
  """
  userData: String!
}

"""
The swap routes including pool information. Used to display by the UI
"""
type GqlSorSwapRoute {
  """
  The hops this route takes
  """
  hops: [GqlSorSwapRouteHop!]!

  """
  Share of this route of the total swap
  """
  share: Float!

  """
  Address of the tokenIn
  """
  tokenIn: String!

  """
  Amount of the tokenIn in human form
  """
  tokenInAmount: AmountHumanReadable!

  """
  Address of the tokenOut
  """
  tokenOut: String!

  """
  Amount of the tokenOut in human form
  """
  tokenOutAmount: AmountHumanReadable!
}

"""
A hop of a route. A route can have many hops meaning it traverses more than one pool.
"""
type GqlSorSwapRouteHop {
  """
  The pool entity of this hop.
  """
  pool: GqlPoolMinimal! @deprecated

  """
  The pool id of this hop.
  """
  poolId: String!

  """
  Address of the tokenIn
  """
  tokenIn: String!

  """
  Amount of the tokenIn in human form
  """
  tokenInAmount: AmountHumanReadable!

  """
  Address of the tokenOut
  """
  tokenOut: String!

  """
  Amount of the tokenOut in human form
  """
  tokenOutAmount: AmountHumanReadable!
}

enum GqlSorSwapType {
  EXACT_IN
  EXACT_OUT
}

type GqlStakedSonicData {
  """
  A list of all the delegated validators.
  """
  delegatedValidators: [GqlStakedSonicDelegatedValidator!]!

  """
  Current exchange rate for stS -> S
  """
  exchangeRate: String!

  """
  The total protocol fee collected in the last 24 hours.
  """
  protocolFee24h: String!

  """
  The total rewards claimed in the last 24 hours.
  """
  rewardsClaimed24h: String!

  """
  The current rebasing APR for stS.
  """
  stakingApr: String!

  """
  Total amount of S in custody of stS. Delegated S plus pool S.
  """
  totalAssets: AmountHumanReadable!

  """
  Total amount of S elegated to validators.
  """
  totalAssetsDelegated: AmountHumanReadable!

  """
  Total amount of S in the pool to be delegated.
  """
  totalAssetsPool: AmountHumanReadable!
}

type GqlStakedSonicDelegatedValidator {
  """
  The amount of S that has been delegated to this validator.
  """
  assetsDelegated: AmountHumanReadable!

  """
  The id of the validator.
  """
  validatorId: String!
}

type GqlStakedSonicSnapshot {
  """
  Current exchange rate for stS -> S
  """
  exchangeRate: String!
  id: ID!

  """
  The total protocol fee collected during that day.
  """
  protocolFee24h: String!

  """
  The total rewards claimed during that day.
  """
  rewardsClaimed24h: String!

  """
  The timestamp of the snapshot. Timestamp is end of day midnight.
  """
  timestamp: Int!

  """
  Total amount of S in custody of stS. Delegated S plus pool S.
  """
  totalAssets: AmountHumanReadable!

  """
  Total amount of S delegated to validators.
  """
  totalAssetsDelegated: AmountHumanReadable!

  """
  Total amount of S in the pool.
  """
  totalAssetsPool: AmountHumanReadable!
}

enum GqlStakedSonicSnapshotDataRange {
  ALL_TIME
  NINETY_DAYS
  ONE_HUNDRED_EIGHTY_DAYS
  ONE_YEAR
  THIRTY_DAYS
}

"""
Inputs for the call data to create the swap transaction. If this input is given, call data is added to the response.
"""
input GqlSwapCallDataInput {
  """
  How long the swap should be valid, provide a timestamp. "999999999999999999" for infinite. Default: infinite
  """
  deadline: Int

  """
  Who receives the output amount.
  """
  receiver: String!

  """
  Who sends the input amount.
  """
  sender: String!

  """
  The max slippage in percent 0.01 -> 0.01%
  """
  slippagePercentage: String!
}

"""
Represents a token in the system
"""
type GqlToken {
  """
  The address of the token
  """
  address: String!

  """
  The chain of the token
  """
  chain: GqlChain!

  """
  The chain ID of the token
  """
  chainId: Int!

  """
  The coingecko ID for this token, if present
  """
  coingeckoId: String

  """
  The number of decimal places for the token
  """
  decimals: Int!

  """
  The description of the token
  """
  description: String

  """
  The Discord URL of the token
  """
  discordUrl: String

  """
  The ERC4626 review data for the token
  """
  erc4626ReviewData: Erc4626ReviewData

  """
  If it is an ERC4626 token, this defines whether we allow it to use the buffer for pool operations.
  """
  isBufferAllowed: Boolean!

  """
  Whether the token is considered an ERC4626 token.
  """
  isErc4626: Boolean!

  """
  The logo URI of the token
  """
  logoURI: String

  """
  If it is an ERC4626 token, this  defines how much can be deposited into the ERC4626 vault.
  """
  maxDeposit: String

  """
  The name of the token
  """
  name: String!

  """
  The rate provider data for the token
  """
  priceRateProviderData: GqlPriceRateProviderData

  """
  The priority of the token, can be used for sorting.
  """
  priority: Int!

  """
  The rate provider data for the token
  """
  rateProviderData: GqlPriceRateProviderData
    @deprecated(reason: "Use priceRateProviderData instead")

  """
  The symbol of the token
  """
  symbol: String!

  """
  The Telegram URL of the token
  """
  telegramUrl: String

  """
  Indicates if the token is tradable
  """
  tradable: Boolean!

  """
  The Twitter username of the token
  """
  twitterUsername: String
  types: [GqlTokenType!]

  """
  The ERC4626 underlying token address, if applicable.
  """
  underlyingTokenAddress: String

  """
  The website URL of the token
  """
  websiteUrl: String
}

input GqlTokenAmountHumanReadable {
  address: String!
  amount: AmountHumanReadable!
}

enum GqlTokenChartDataRange {
  ALL
  NINETY_DAY
  ONE_HUNDRED_EIGHTY_DAY
  ONE_YEAR
  SEVEN_DAY
  THIRTY_DAY
}

"""
Represents additional data for a token
"""
type GqlTokenDynamicData {
  """
  The all-time high price of the token
  """
  ath: Float!

  """
  The all-time low price of the token
  """
  atl: Float!

  """
  The fully diluted valuation of the token
  """
  fdv: String

  """
  The highest price in the last 24 hours
  """
  high24h: Float!

  """
  The unique identifier of the dynamic data
  """
  id: String!

  """
  The lowest price in the last 24 hours
  """
  low24h: Float!

  """
  The market capitalization of the token
  """
  marketCap: String

  """
  The current price of the token
  """
  price: Float!

  """
  The price change in the last 24 hours
  """
  priceChange24h: Float!

  """
  The percentage price change in the last 7 days
  """
  priceChangePercent7d: Float

  """
  The percentage price change in the last 14 days
  """
  priceChangePercent14d: Float

  """
  The percentage price change in the last 24 hours
  """
  priceChangePercent24h: Float!

  """
  The percentage price change in the last 30 days
  """
  priceChangePercent30d: Float

  """
  The address of the token
  """
  tokenAddress: String!

  """
  The timestamp when the data was last updated
  """
  updatedAt: String!
}

"""
Provide filters for tokens
"""
input GqlTokenFilter {
  """
  Only return tokens with these addresses
  """
  tokensIn: [String!]

  """
  Filter by token type
  """
  typeIn: [GqlTokenType!]
}

"""
Result of the poolReloadPools mutation
"""
type GqlTokenMutationResult {
  """
  The chain that was reloaded.
  """
  chain: GqlChain!

  """
  The error message
  """
  error: String

  """
  Whether it was successful or not.
  """
  success: Boolean!
}

type GqlTokenPrice {
  address: String!
  chain: GqlChain!
  price: Float!
  updatedAt: Int!
  updatedBy: String
}

type GqlTokenPriceChartDataItem {
  id: ID!
  price: AmountHumanReadable!
  timestamp: Int!
}

enum GqlTokenType {
  BLOCKED_V2
  BLOCKED_V3
  BPT
  ERC4626
  PHANTOM_BPT
  WHITE_LISTED @deprecated(reason: "Use BLOCKED instead")
}

type GqlUserStakedBalance {
  """
  The staked BPT balance as float.
  """
  balance: AmountHumanReadable!

  """
  The steaked BPT balance in USD as float.
  """
  balanceUsd: Float!

  """
  The id of the staking to match with GqlPoolStaking.id.
  """
  stakingId: String!

  """
  The staking type (Gauge, farm, aura, etc.) in which this balance is staked.
  """
  stakingType: GqlPoolStakingType!
}

type GqlVeBalBalance {
  balance: AmountHumanReadable!
  chain: GqlChain!
  locked: AmountHumanReadable!
  lockedUsd: AmountHumanReadable!
}

"""
Represents a snapshot of a VeBal lock at a specific point in time.
"""
type GqlVeBalLockSnapshot {
  """
  The locked balance at that time.
  """
  balance: AmountHumanReadable!
  bias: String!
  slope: String!

  """
  The timestamp of the snapshot, snapshots are taking at lock events.
  """
  timestamp: Int!
}

type GqlVeBalUserData {
  balance: AmountHumanReadable!
  lockSnapshots: [GqlVeBalLockSnapshot!]!
  locked: AmountHumanReadable!
  lockedUsd: AmountHumanReadable!
  rank: Int
}

"""
The Gauge that can be voted on through veBAL and that will ultimately receive the rewards.
"""
type GqlVotingGauge {
  """
  The timestamp the gauge was added.
  """
  addedTimestamp: Int

  """
  The address of the root gauge on Ethereum mainnet.
  """
  address: Bytes!

  """
  The address of the child gauge on the specific chain.
  """
  childGaugeAddress: Bytes

  """
  Whether the gauge is killed or not.
  """
  isKilled: Boolean!

  """
  The relative weight the gauge received this epoch (not more than 1.0).
  """
  relativeWeight: String!

  """
  The relative weight cap. 1.0 for uncapped.
  """
  relativeWeightCap: String
}

"""
A token inside of a pool with a voting gauge.
"""
type GqlVotingGaugeToken {
  """
  The address of the token.
  """
  address: String!

  """
  The URL to the token logo.
  """
  logoURI: String!

  """
  The symbol of the token.
  """
  symbol: String!

  """
  Underlying token address
  """
  underlyingTokenAddress: String

  """
  If it is a weighted pool, the weigh of the token is shown here in %. 0.5 = 50%.
  """
  weight: String
}

"""
The pool that can be voted on through veBAL
"""
type GqlVotingPool {
  """
  The address of the pool.
  """
  address: Bytes!

  """
  The chain this pool is on.
  """
  chain: GqlChain!

  """
  The gauge that is connected to the pool and that will receive the rewards.
  """
  gauge: GqlVotingGauge!

  """
  Pool ID
  """
  id: ID!

  """
  Returns all pool tokens, including BPTs and nested pools if there are any. Only one nested level deep.
  """
  poolTokens: [GqlPoolTokenDetail!]!
  protocolVersion: Int!

  """
  The symbol of the pool.
  """
  symbol: String!

  """
  List of tags assigned by the team based on external factors
  """
  tags: [String]

  """
  The tokens inside the pool.
  """
  tokens: [GqlVotingGaugeToken!]!

  """
  The type of the pool.
  """
  type: GqlPoolType!
}

type GradualWeightUpdate {
  endTimestamp: BigInt!
  endWeights: [BigInt!]!
  id: ID!
  poolId: Pool!
  scheduledTimestamp: Int!
  startTimestamp: BigInt!
  startWeights: [BigInt!]!
}

input GradualWeightUpdate_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [GradualWeightUpdate_filter]
  endTimestamp: BigInt
  endTimestamp_gt: BigInt
  endTimestamp_gte: BigInt
  endTimestamp_in: [BigInt!]
  endTimestamp_lt: BigInt
  endTimestamp_lte: BigInt
  endTimestamp_not: BigInt
  endTimestamp_not_in: [BigInt!]
  endWeights: [BigInt!]
  endWeights_contains: [BigInt!]
  endWeights_contains_nocase: [BigInt!]
  endWeights_not: [BigInt!]
  endWeights_not_contains: [BigInt!]
  endWeights_not_contains_nocase: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [GradualWeightUpdate_filter]
  poolId: String
  poolId_: Pool_filter
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  scheduledTimestamp: Int
  scheduledTimestamp_gt: Int
  scheduledTimestamp_gte: Int
  scheduledTimestamp_in: [Int!]
  scheduledTimestamp_lt: Int
  scheduledTimestamp_lte: Int
  scheduledTimestamp_not: Int
  scheduledTimestamp_not_in: [Int!]
  startTimestamp: BigInt
  startTimestamp_gt: BigInt
  startTimestamp_gte: BigInt
  startTimestamp_in: [BigInt!]
  startTimestamp_lt: BigInt
  startTimestamp_lte: BigInt
  startTimestamp_not: BigInt
  startTimestamp_not_in: [BigInt!]
  startWeights: [BigInt!]
  startWeights_contains: [BigInt!]
  startWeights_contains_nocase: [BigInt!]
  startWeights_not: [BigInt!]
  startWeights_not_contains: [BigInt!]
  startWeights_not_contains_nocase: [BigInt!]
}

enum GradualWeightUpdate_orderBy {
  endTimestamp
  endWeights
  id
  poolId
  poolId__address
  poolId__alpha
  poolId__amp
  poolId__baseToken
  poolId__beta
  poolId__c
  poolId__createTime
  poolId__dSq
  poolId__delta
  poolId__epsilon
  poolId__expiryTime
  poolId__factory
  poolId__holdersCount
  poolId__id
  poolId__isInRecoveryMode
  poolId__isPaused
  poolId__joinExitEnabled
  poolId__lambda
  poolId__lastJoinExitAmp
  poolId__lastPostJoinExitInvariant
  poolId__lowerTarget
  poolId__mainIndex
  poolId__managementAumFee
  poolId__managementFee
  poolId__mustAllowlistLPs
  poolId__name
  poolId__oracleEnabled
  poolId__owner
  poolId__poolType
  poolId__poolTypeVersion
  poolId__principalToken
  poolId__protocolAumFeeCache
  poolId__protocolId
  poolId__protocolSwapFeeCache
  poolId__protocolYieldFeeCache
  poolId__root3Alpha
  poolId__s
  poolId__sqrtAlpha
  poolId__sqrtBeta
  poolId__strategyType
  poolId__swapEnabled
  poolId__swapEnabledCurationSignal
  poolId__swapEnabledInternal
  poolId__swapFee
  poolId__swapsCount
  poolId__symbol
  poolId__tauAlphaX
  poolId__tauAlphaY
  poolId__tauBetaX
  poolId__tauBetaY
  poolId__totalAumFeeCollectedInBPT
  poolId__totalLiquidity
  poolId__totalLiquiditySansBPT
  poolId__totalProtocolFee
  poolId__totalProtocolFeePaidInBPT
  poolId__totalShares
  poolId__totalSwapFee
  poolId__totalSwapVolume
  poolId__totalWeight
  poolId__tx
  poolId__u
  poolId__unitSeconds
  poolId__upperTarget
  poolId__v
  poolId__w
  poolId__wrappedIndex
  poolId__z
  scheduledTimestamp
  startTimestamp
  startWeights
}

type HookConfig {
  """
  True when hook can change the amounts send to the vault. Necessary to deduct the fees.
  """
  enableHookAdjustedAmounts: Boolean!
  shouldCallAfterAddLiquidity: Boolean!
  shouldCallAfterInitialize: Boolean!
  shouldCallAfterRemoveLiquidity: Boolean!
  shouldCallAfterSwap: Boolean!
  shouldCallBeforeAddLiquidity: Boolean!
  shouldCallBeforeInitialize: Boolean!
  shouldCallBeforeRemoveLiquidity: Boolean!
  shouldCallBeforeSwap: Boolean!
  shouldCallComputeDynamicSwapFee: Boolean!
}

union HookParams =
  | ExitFeeHookParams
  | FeeTakingHookParams
  | MevTaxHookParams
  | StableSurgeHookParams

"""
8 bytes signed integer
"""
scalar Int8

enum InvestType {
  Exit
  Join
}

scalar JSON

type JoinExit {
  amounts: [BigDecimal!]!
  block: BigInt
  id: ID!
  pool: Pool!
  sender: Bytes!
  timestamp: Int!
  tx: Bytes!
  type: InvestType!
  user: User!
  valueUSD: BigDecimal
}

input JoinExit_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amounts: [BigDecimal!]
  amounts_contains: [BigDecimal!]
  amounts_contains_nocase: [BigDecimal!]
  amounts_not: [BigDecimal!]
  amounts_not_contains: [BigDecimal!]
  amounts_not_contains_nocase: [BigDecimal!]
  and: [JoinExit_filter]
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [JoinExit_filter]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  sender: Bytes
  sender_contains: Bytes
  sender_gt: Bytes
  sender_gte: Bytes
  sender_in: [Bytes!]
  sender_lt: Bytes
  sender_lte: Bytes
  sender_not: Bytes
  sender_not_contains: Bytes
  sender_not_in: [Bytes!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  tx: Bytes
  tx_contains: Bytes
  tx_gt: Bytes
  tx_gte: Bytes
  tx_in: [Bytes!]
  tx_lt: Bytes
  tx_lte: Bytes
  tx_not: Bytes
  tx_not_contains: Bytes
  tx_not_in: [Bytes!]
  type: InvestType
  type_in: [InvestType!]
  type_not: InvestType
  type_not_in: [InvestType!]
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
  valueUSD: BigDecimal
  valueUSD_gt: BigDecimal
  valueUSD_gte: BigDecimal
  valueUSD_in: [BigDecimal!]
  valueUSD_lt: BigDecimal
  valueUSD_lte: BigDecimal
  valueUSD_not: BigDecimal
  valueUSD_not_in: [BigDecimal!]
}

enum JoinExit_orderBy {
  amounts
  block
  id
  pool
  pool__address
  pool__alpha
  pool__amp
  pool__baseToken
  pool__beta
  pool__c
  pool__createTime
  pool__dSq
  pool__delta
  pool__epsilon
  pool__expiryTime
  pool__factory
  pool__holdersCount
  pool__id
  pool__isInRecoveryMode
  pool__isPaused
  pool__joinExitEnabled
  pool__lambda
  pool__lastJoinExitAmp
  pool__lastPostJoinExitInvariant
  pool__lowerTarget
  pool__mainIndex
  pool__managementAumFee
  pool__managementFee
  pool__mustAllowlistLPs
  pool__name
  pool__oracleEnabled
  pool__owner
  pool__poolType
  pool__poolTypeVersion
  pool__principalToken
  pool__protocolAumFeeCache
  pool__protocolId
  pool__protocolSwapFeeCache
  pool__protocolYieldFeeCache
  pool__root3Alpha
  pool__s
  pool__sqrtAlpha
  pool__sqrtBeta
  pool__strategyType
  pool__swapEnabled
  pool__swapEnabledCurationSignal
  pool__swapEnabledInternal
  pool__swapFee
  pool__swapsCount
  pool__symbol
  pool__tauAlphaX
  pool__tauAlphaY
  pool__tauBetaX
  pool__tauBetaY
  pool__totalAumFeeCollectedInBPT
  pool__totalLiquidity
  pool__totalLiquiditySansBPT
  pool__totalProtocolFee
  pool__totalProtocolFeePaidInBPT
  pool__totalShares
  pool__totalSwapFee
  pool__totalSwapVolume
  pool__totalWeight
  pool__tx
  pool__u
  pool__unitSeconds
  pool__upperTarget
  pool__v
  pool__w
  pool__wrappedIndex
  pool__z
  sender
  timestamp
  tx
  type
  user
  user__id
  valueUSD
}

input LBPMetadataInput {
  description: String!
  discord: String
  farcaster: String
  lbpName: String!
  telegram: String
  tokenLogo: String!
  website: String!
  x: String
}

type LBPPriceChartData {
  buyVolume: Float!
  cumulativeFees: Float!
  cumulativeVolume: Float!
  fees: Float!
  intervalTimestamp: Int! @deprecated
  projectTokenBalance: Float!
  projectTokenPrice: Float!
  reservePrice: Float!
  reserveTokenBalance: Float!
  sellVolume: Float!
  swapCount: Int!
  timestamp: Int!
  tvl: Float!
  volume: Float!
}

input LBPoolInput {
  address: String!
  chain: GqlChain!
}

type LatestPrice {
  asset: Bytes!
  block: BigInt!
  id: ID!
  poolId: Pool!
  price: BigDecimal!
  pricingAsset: Bytes!
}

input LatestPrice_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [LatestPrice_filter]
  asset: Bytes
  asset_contains: Bytes
  asset_gt: Bytes
  asset_gte: Bytes
  asset_in: [Bytes!]
  asset_lt: Bytes
  asset_lte: Bytes
  asset_not: Bytes
  asset_not_contains: Bytes
  asset_not_in: [Bytes!]
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [LatestPrice_filter]
  poolId: String
  poolId_: Pool_filter
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  price: BigDecimal
  price_gt: BigDecimal
  price_gte: BigDecimal
  price_in: [BigDecimal!]
  price_lt: BigDecimal
  price_lte: BigDecimal
  price_not: BigDecimal
  price_not_in: [BigDecimal!]
  pricingAsset: Bytes
  pricingAsset_contains: Bytes
  pricingAsset_gt: Bytes
  pricingAsset_gte: Bytes
  pricingAsset_in: [Bytes!]
  pricingAsset_lt: Bytes
  pricingAsset_lte: Bytes
  pricingAsset_not: Bytes
  pricingAsset_not_contains: Bytes
  pricingAsset_not_in: [Bytes!]
}

enum LatestPrice_orderBy {
  asset
  block
  id
  poolId
  poolId__address
  poolId__alpha
  poolId__amp
  poolId__baseToken
  poolId__beta
  poolId__c
  poolId__createTime
  poolId__dSq
  poolId__delta
  poolId__epsilon
  poolId__expiryTime
  poolId__factory
  poolId__holdersCount
  poolId__id
  poolId__isInRecoveryMode
  poolId__isPaused
  poolId__joinExitEnabled
  poolId__lambda
  poolId__lastJoinExitAmp
  poolId__lastPostJoinExitInvariant
  poolId__lowerTarget
  poolId__mainIndex
  poolId__managementAumFee
  poolId__managementFee
  poolId__mustAllowlistLPs
  poolId__name
  poolId__oracleEnabled
  poolId__owner
  poolId__poolType
  poolId__poolTypeVersion
  poolId__principalToken
  poolId__protocolAumFeeCache
  poolId__protocolId
  poolId__protocolSwapFeeCache
  poolId__protocolYieldFeeCache
  poolId__root3Alpha
  poolId__s
  poolId__sqrtAlpha
  poolId__sqrtBeta
  poolId__strategyType
  poolId__swapEnabled
  poolId__swapEnabledCurationSignal
  poolId__swapEnabledInternal
  poolId__swapFee
  poolId__swapsCount
  poolId__symbol
  poolId__tauAlphaX
  poolId__tauAlphaY
  poolId__tauBetaX
  poolId__tauBetaY
  poolId__totalAumFeeCollectedInBPT
  poolId__totalLiquidity
  poolId__totalLiquiditySansBPT
  poolId__totalProtocolFee
  poolId__totalProtocolFeePaidInBPT
  poolId__totalShares
  poolId__totalSwapFee
  poolId__totalSwapVolume
  poolId__totalWeight
  poolId__tx
  poolId__u
  poolId__unitSeconds
  poolId__upperTarget
  poolId__v
  poolId__w
  poolId__wrappedIndex
  poolId__z
  price
  pricingAsset
}

"""
LBP specific params for v3 pools only.
"""
type LiquidityBootstrappingPoolV3Params {
  endTime: Int!
  startTime: Int!
}

type LiquidityGauge {
  """
  Factory contract address
  """
  factory: GaugeFactory!

  """
  Reference to Gauge entity - created when LiquidityGauge is added to GaugeController
  """
  gauge: Gauge

  """
  LiquidityGauge contract address
  """
  id: ID!

  """
  Whether Balancer DAO killed the gauge
  """
  isKilled: Boolean!

  """
  Whether the LiquidityGauge is the most recent added to GaugeController
  """
  isPreferentialGauge: Boolean!

  """
  Reference to Pool entity
  """
  pool: Pool

  """
  Address of the pool (lp_token of the gauge)
  """
  poolAddress: Bytes!

  """
  Pool ID if lp_token is a Balancer pool; null otherwise
  """
  poolId: Bytes

  """
  Relative weight cap of the gauge (0.01 = 1%) - V2 factories only
  """
  relativeWeightCap: BigDecimal

  """
  List of reward tokens depositted in the gauge - ChildChainLiquidityGauge only
  """
  rewardTokensList: [Bytes!]

  """
  List of user shares
  """
  shares(
    first: Int = 100
    orderBy: GaugeShare_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: GaugeShare_filter
  ): [GaugeShare!]

  """
  Address of the contract that streams reward tokens to the gauge - ChildChainLiquidityGauge only
  """
  streamer: Bytes

  """
  ERC20 token symbol
  """
  symbol: String!

  """
  List of reward tokens depositted in the gauge
  """
  tokens(
    first: Int = 100
    orderBy: RewardToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: RewardToken_filter
  ): [RewardToken!]

  """
  Total of BPTs users have staked in the LiquidityGauge
  """
  totalSupply: BigDecimal!
}

input LiquidityGauge_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [LiquidityGauge_filter]
  factory: String
  factory_: GaugeFactory_filter
  factory_contains: String
  factory_contains_nocase: String
  factory_ends_with: String
  factory_ends_with_nocase: String
  factory_gt: String
  factory_gte: String
  factory_in: [String!]
  factory_lt: String
  factory_lte: String
  factory_not: String
  factory_not_contains: String
  factory_not_contains_nocase: String
  factory_not_ends_with: String
  factory_not_ends_with_nocase: String
  factory_not_in: [String!]
  factory_not_starts_with: String
  factory_not_starts_with_nocase: String
  factory_starts_with: String
  factory_starts_with_nocase: String
  gauge: String
  gauge_: Gauge_filter
  gauge_contains: String
  gauge_contains_nocase: String
  gauge_ends_with: String
  gauge_ends_with_nocase: String
  gauge_gt: String
  gauge_gte: String
  gauge_in: [String!]
  gauge_lt: String
  gauge_lte: String
  gauge_not: String
  gauge_not_contains: String
  gauge_not_contains_nocase: String
  gauge_not_ends_with: String
  gauge_not_ends_with_nocase: String
  gauge_not_in: [String!]
  gauge_not_starts_with: String
  gauge_not_starts_with_nocase: String
  gauge_starts_with: String
  gauge_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isKilled: Boolean
  isKilled_in: [Boolean!]
  isKilled_not: Boolean
  isKilled_not_in: [Boolean!]
  isPreferentialGauge: Boolean
  isPreferentialGauge_in: [Boolean!]
  isPreferentialGauge_not: Boolean
  isPreferentialGauge_not_in: [Boolean!]
  or: [LiquidityGauge_filter]
  pool: String
  poolAddress: Bytes
  poolAddress_contains: Bytes
  poolAddress_gt: Bytes
  poolAddress_gte: Bytes
  poolAddress_in: [Bytes!]
  poolAddress_lt: Bytes
  poolAddress_lte: Bytes
  poolAddress_not: Bytes
  poolAddress_not_contains: Bytes
  poolAddress_not_in: [Bytes!]
  poolId: Bytes
  poolId_contains: Bytes
  poolId_gt: Bytes
  poolId_gte: Bytes
  poolId_in: [Bytes!]
  poolId_lt: Bytes
  poolId_lte: Bytes
  poolId_not: Bytes
  poolId_not_contains: Bytes
  poolId_not_in: [Bytes!]
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  relativeWeightCap: BigDecimal
  relativeWeightCap_gt: BigDecimal
  relativeWeightCap_gte: BigDecimal
  relativeWeightCap_in: [BigDecimal!]
  relativeWeightCap_lt: BigDecimal
  relativeWeightCap_lte: BigDecimal
  relativeWeightCap_not: BigDecimal
  relativeWeightCap_not_in: [BigDecimal!]
  rewardTokensList: [Bytes!]
  rewardTokensList_contains: [Bytes!]
  rewardTokensList_contains_nocase: [Bytes!]
  rewardTokensList_not: [Bytes!]
  rewardTokensList_not_contains: [Bytes!]
  rewardTokensList_not_contains_nocase: [Bytes!]
  shares_: GaugeShare_filter
  streamer: Bytes
  streamer_contains: Bytes
  streamer_gt: Bytes
  streamer_gte: Bytes
  streamer_in: [Bytes!]
  streamer_lt: Bytes
  streamer_lte: Bytes
  streamer_not: Bytes
  streamer_not_contains: Bytes
  streamer_not_in: [Bytes!]
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  tokens_: RewardToken_filter
  totalSupply: BigDecimal
  totalSupply_gt: BigDecimal
  totalSupply_gte: BigDecimal
  totalSupply_in: [BigDecimal!]
  totalSupply_lt: BigDecimal
  totalSupply_lte: BigDecimal
  totalSupply_not: BigDecimal
  totalSupply_not_in: [BigDecimal!]
}

enum LiquidityGauge_orderBy {
  factory
  factory__id
  factory__numGauges
  gauge
  gauge__addedTimestamp
  gauge__address
  gauge__id
  id
  isKilled
  isPreferentialGauge
  pool
  poolAddress
  poolId
  pool__address
  pool__id
  pool__poolId
  relativeWeightCap
  rewardTokensList
  shares
  streamer
  symbol
  tokens
  totalSupply
}

"""
Liquidity management settings for v3 pools.
"""
type LiquidityManagement {
  """
  Indicates whether this pool has disabled add and removes of unbalanced/non-proportional liquidity. Meaning it will only support proportional add and remove liquidity.
  """
  disableUnbalancedLiquidity: Boolean

  """
  Whether this pool support additional, custom add liquditiy operations apart from proportional, unbalanced and single asset.
  """
  enableAddLiquidityCustom: Boolean

  """
  Indicates whether donation is enabled. Meaning you can send funds to the pool without receiving a BPT.
  """
  enableDonation: Boolean

  """
  Whether this pool support additional, custom remove liquditiy operations apart from proportional, unbalanced and single asset.
  """
  enableRemoveLiquidityCustom: Boolean
}

type LockSnapshot {
  """
  veBAL balance at the moment user locks
  """
  bias: BigDecimal!

  """
  Equal to <userAddress>-<timestamp>
  """
  id: ID!

  """
  veBAL decay rate (per second)
  """
  slope: BigDecimal!

  """
  Timestamp at which the snapshot was taken [seconds]
  """
  timestamp: Int!

  """
  Reference to User entity
  """
  user: User!
}

input LockSnapshot_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [LockSnapshot_filter]
  bias: BigDecimal
  bias_gt: BigDecimal
  bias_gte: BigDecimal
  bias_in: [BigDecimal!]
  bias_lt: BigDecimal
  bias_lte: BigDecimal
  bias_not: BigDecimal
  bias_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [LockSnapshot_filter]
  slope: BigDecimal
  slope_gt: BigDecimal
  slope_gte: BigDecimal
  slope_in: [BigDecimal!]
  slope_lt: BigDecimal
  slope_lte: BigDecimal
  slope_not: BigDecimal
  slope_not_in: [BigDecimal!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
}

enum LockSnapshot_orderBy {
  bias
  id
  slope
  timestamp
  user
  user__id
}

type ManagementOperation {
  cashDelta: BigDecimal!
  id: ID!
  managedDelta: BigDecimal!
  poolTokenId: PoolToken!
  timestamp: Int!
  type: OperationType!
}

input ManagementOperation_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [ManagementOperation_filter]
  cashDelta: BigDecimal
  cashDelta_gt: BigDecimal
  cashDelta_gte: BigDecimal
  cashDelta_in: [BigDecimal!]
  cashDelta_lt: BigDecimal
  cashDelta_lte: BigDecimal
  cashDelta_not: BigDecimal
  cashDelta_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  managedDelta: BigDecimal
  managedDelta_gt: BigDecimal
  managedDelta_gte: BigDecimal
  managedDelta_in: [BigDecimal!]
  managedDelta_lt: BigDecimal
  managedDelta_lte: BigDecimal
  managedDelta_not: BigDecimal
  managedDelta_not_in: [BigDecimal!]
  or: [ManagementOperation_filter]
  poolTokenId: String
  poolTokenId_: PoolToken_filter
  poolTokenId_contains: String
  poolTokenId_contains_nocase: String
  poolTokenId_ends_with: String
  poolTokenId_ends_with_nocase: String
  poolTokenId_gt: String
  poolTokenId_gte: String
  poolTokenId_in: [String!]
  poolTokenId_lt: String
  poolTokenId_lte: String
  poolTokenId_not: String
  poolTokenId_not_contains: String
  poolTokenId_not_contains_nocase: String
  poolTokenId_not_ends_with: String
  poolTokenId_not_ends_with_nocase: String
  poolTokenId_not_in: [String!]
  poolTokenId_not_starts_with: String
  poolTokenId_not_starts_with_nocase: String
  poolTokenId_starts_with: String
  poolTokenId_starts_with_nocase: String
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  type: OperationType
  type_in: [OperationType!]
  type_not: OperationType
  type_not_in: [OperationType!]
}

enum ManagementOperation_orderBy {
  cashDelta
  id
  managedDelta
  poolTokenId
  poolTokenId__address
  poolTokenId__assetManager
  poolTokenId__balance
  poolTokenId__cashBalance
  poolTokenId__decimals
  poolTokenId__id
  poolTokenId__index
  poolTokenId__isExemptFromYieldProtocolFee
  poolTokenId__managedBalance
  poolTokenId__name
  poolTokenId__oldPriceRate
  poolTokenId__paidProtocolFees
  poolTokenId__priceRate
  poolTokenId__symbol
  poolTokenId__weight
  timestamp
  type
}

"""
MevTax hook specific params. Percentage format is 0.01 -> 0.01%.
"""
type MevTaxHookParams {
  maxMevSwapFeePercentage: String
  mevTaxMultiplier: String
  mevTaxThreshold: String
}

type Mutation {
  beetsPoolLoadReliquarySnapshotsForAllFarms(chain: GqlChain!): String!
  createLBP(input: CreateLBPInput!, type: GqlPoolType): Boolean!
  poolLoadOnChainDataForAllPools(
    chains: [GqlChain!]!
  ): [GqlPoolMutationResult!]!
  poolLoadSnapshotsForPools(chain: GqlChain!, poolId: String!): String!
  poolReloadAllPoolAprs(chain: GqlChain!): String!
  poolReloadPools(chains: [GqlChain!]!): [GqlPoolMutationResult!]!
  poolReloadStakingForAllPools(
    chain: GqlChain!
    stakingTypes: [GqlPoolStakingType!]!
  ): String!
  poolReloadSwaps(chain: GqlChain!, poolId: String!): String!
  poolSyncAllPoolsFromSubgraph(chain: GqlChain!): [String!]!
  poolSyncFxQuoteTokens(chains: [GqlChain!]!): [GqlPoolMutationResult!]!
  poolUpdateLiquidityValuesForAllPools(chain: GqlChain!): String!
  protocolCacheMetrics(chain: GqlChain!): String!
  tokenDeleteTokenType(
    chain: GqlChain!
    tokenAddress: String!
    type: GqlTokenType!
  ): String!
  tokenReloadAllTokenTypes(chain: GqlChain!): String!
  tokenReloadErc4626Tokens(chains: [GqlChain!]!): [GqlTokenMutationResult!]!
  tokenReloadTokenPrices(chains: [GqlChain!]!): Boolean
  tokenSyncLatestFxPrices(chain: GqlChain!): String!
  tokenSyncTokenDefinitions: String!
  userInitStakedBalances(
    chain: GqlChain!
    stakingTypes: [GqlPoolStakingType!]!
  ): String!
  userInitWalletBalancesForAllPools(chain: GqlChain!): String!
  userSyncChangedStakedBalances(chain: GqlChain!): String!
  userSyncChangedWalletBalancesForAllPools(chain: GqlChain!): String!
  veBalSyncAllUserBalances(chain: GqlChain!): String!
  veBalSyncTotalSupply(chain: GqlChain!): String!
}

type OmniVotingEscrowLock {
  """
  veBAL balance at the moment user locks
  """
  bias: BigDecimal!

  """
  Chain where the lock was bridged to
  """
  dstChainId: Int!

  """
  Equal to: <userAdress>-<omniVotingEscrow>
  """
  id: ID!

  """
  User on the local chain (reference to User entity)
  """
  localUser: User!

  """
  User address on the remote chain
  """
  remoteUser: Bytes!

  """
  veBAL decay rate (per second)
  """
  slope: BigDecimal!

  """
  Timestamp the lock was created [seconds]
  """
  timestamp: Int!

  """
  Reference to VotingEscrow entity
  """
  votingEscrowID: VotingEscrow!
}

input OmniVotingEscrowLock_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [OmniVotingEscrowLock_filter]
  bias: BigDecimal
  bias_gt: BigDecimal
  bias_gte: BigDecimal
  bias_in: [BigDecimal!]
  bias_lt: BigDecimal
  bias_lte: BigDecimal
  bias_not: BigDecimal
  bias_not_in: [BigDecimal!]
  dstChainId: Int
  dstChainId_gt: Int
  dstChainId_gte: Int
  dstChainId_in: [Int!]
  dstChainId_lt: Int
  dstChainId_lte: Int
  dstChainId_not: Int
  dstChainId_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  localUser: String
  localUser_: User_filter
  localUser_contains: String
  localUser_contains_nocase: String
  localUser_ends_with: String
  localUser_ends_with_nocase: String
  localUser_gt: String
  localUser_gte: String
  localUser_in: [String!]
  localUser_lt: String
  localUser_lte: String
  localUser_not: String
  localUser_not_contains: String
  localUser_not_contains_nocase: String
  localUser_not_ends_with: String
  localUser_not_ends_with_nocase: String
  localUser_not_in: [String!]
  localUser_not_starts_with: String
  localUser_not_starts_with_nocase: String
  localUser_starts_with: String
  localUser_starts_with_nocase: String
  or: [OmniVotingEscrowLock_filter]
  remoteUser: Bytes
  remoteUser_contains: Bytes
  remoteUser_gt: Bytes
  remoteUser_gte: Bytes
  remoteUser_in: [Bytes!]
  remoteUser_lt: Bytes
  remoteUser_lte: Bytes
  remoteUser_not: Bytes
  remoteUser_not_contains: Bytes
  remoteUser_not_in: [Bytes!]
  slope: BigDecimal
  slope_gt: BigDecimal
  slope_gte: BigDecimal
  slope_in: [BigDecimal!]
  slope_lt: BigDecimal
  slope_lte: BigDecimal
  slope_not: BigDecimal
  slope_not_in: [BigDecimal!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  votingEscrowID: String
  votingEscrowID_: VotingEscrow_filter
  votingEscrowID_contains: String
  votingEscrowID_contains_nocase: String
  votingEscrowID_ends_with: String
  votingEscrowID_ends_with_nocase: String
  votingEscrowID_gt: String
  votingEscrowID_gte: String
  votingEscrowID_in: [String!]
  votingEscrowID_lt: String
  votingEscrowID_lte: String
  votingEscrowID_not: String
  votingEscrowID_not_contains: String
  votingEscrowID_not_contains_nocase: String
  votingEscrowID_not_ends_with: String
  votingEscrowID_not_ends_with_nocase: String
  votingEscrowID_not_in: [String!]
  votingEscrowID_not_starts_with: String
  votingEscrowID_not_starts_with_nocase: String
  votingEscrowID_starts_with: String
  votingEscrowID_starts_with_nocase: String
}

enum OmniVotingEscrowLock_orderBy {
  bias
  dstChainId
  id
  localUser
  localUser__id
  remoteUser
  slope
  timestamp
  votingEscrowID
  votingEscrowID__id
  votingEscrowID__stakedSupply
}

enum OperationType {
  Deposit
  Update
  Withdraw
}

"""
Defines the order direction, either ascending or descending
"""
enum OrderDirection {
  asc
  desc
}

type Pool {
  """
  Address of the pool (lp_token of the gauge)
  """
  address: Bytes!
  alpha: BigDecimal
  amp: BigInt
  ampUpdates(
    first: Int = 100
    orderBy: AmpUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: AmpUpdate_filter
  ): [AmpUpdate!]
  baseToken: Bytes
  beta: BigDecimal
  c: BigDecimal
  circuitBreakers(
    first: Int = 100
    orderBy: CircuitBreaker_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: CircuitBreaker_filter
  ): [CircuitBreaker!]
  createTime: Int!
  dSq: BigDecimal
  delta: BigDecimal
  epsilon: BigDecimal
  expiryTime: BigInt
  factory: Bytes

  """
  List of gauges created for the pool
  """
  gauges(
    first: Int = 100
    orderBy: LiquidityGauge_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: LiquidityGauge_filter
  ): [LiquidityGauge!]

  """
  List of the pool's gauges addresses
  """
  gaugesList: [Bytes!]!
  historicalValues(
    first: Int = 100
    orderBy: PoolHistoricalLiquidity_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: PoolHistoricalLiquidity_filter
  ): [PoolHistoricalLiquidity!]
  holdersCount: BigInt!

  """
  Address of the pool (lp_token of the gauge)
  """
  id: ID!
  isInRecoveryMode: Boolean
  isPaused: Boolean
  joinExitEnabled: Boolean
  joinsExits(
    first: Int = 100
    orderBy: JoinExit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: JoinExit_filter
  ): [JoinExit!]
  lambda: BigDecimal
  lastJoinExitAmp: BigInt
  lastPostJoinExitInvariant: BigDecimal
  latestAmpUpdate: AmpUpdate
  lowerTarget: BigDecimal
  mainIndex: Int
  managementAumFee: BigDecimal
  managementFee: BigDecimal
  mustAllowlistLPs: Boolean
  name: String
  oracleEnabled: Boolean!
  owner: Bytes

  """
  Pool ID if lp_token is a Balancer pool; null otherwise
  """
  poolId: Bytes
  poolType: String
  poolTypeVersion: Int

  """
  Most recent, unkilled gauge in the GaugeController
  """
  preferentialGauge: LiquidityGauge
  priceRateProviders(
    first: Int = 100
    orderBy: PriceRateProvider_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: PriceRateProvider_filter
  ): [PriceRateProvider!]
  principalToken: Bytes
  protocolAumFeeCache: BigDecimal
  protocolId: Int
  protocolIdData: ProtocolIdData
  protocolSwapFeeCache: BigDecimal
  protocolYieldFeeCache: BigDecimal
  root3Alpha: BigDecimal
  s: BigDecimal
  shares(
    first: Int = 100
    orderBy: PoolShare_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: PoolShare_filter
  ): [PoolShare!]
  snapshots(
    first: Int = 100
    orderBy: PoolSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: PoolSnapshot_filter
  ): [PoolSnapshot!]
  sqrtAlpha: BigDecimal
  sqrtBeta: BigDecimal
  strategyType: Int!

  """
  Indicates if a pool can be swapped against. Combines multiple sources, including offchain curation
  """
  swapEnabled: Boolean!

  """
  External indication from an offchain permissioned actor
  """
  swapEnabledCurationSignal: Boolean

  """
  The native swapEnabled boolean. internal to the pool. Only applies to Gyro, LBPs and InvestmentPools
  """
  swapEnabledInternal: Boolean
  swapFee: BigDecimal!
  swaps(
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Swap_filter
  ): [Swap!]
  swapsCount: BigInt!
  symbol: String
  tauAlphaX: BigDecimal
  tauAlphaY: BigDecimal
  tauBetaX: BigDecimal
  tauBetaY: BigDecimal
  tokens(
    first: Int = 100
    orderBy: PoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: PoolToken_filter
  ): [PoolToken!]
  tokensList: [Bytes!]!
  totalAumFeeCollectedInBPT: BigDecimal
  totalLiquidity: BigDecimal!
  totalLiquiditySansBPT: BigDecimal
  totalProtocolFee: BigDecimal
  totalProtocolFeePaidInBPT: BigDecimal
  totalShares: BigDecimal!
  totalSwapFee: BigDecimal!
  totalSwapVolume: BigDecimal!
  totalWeight: BigDecimal
  tx: Bytes
  u: BigDecimal
  unitSeconds: BigInt
  upperTarget: BigDecimal
  v: BigDecimal
  vaultID: Balancer!
  w: BigDecimal
  weightUpdates(
    first: Int = 100
    orderBy: GradualWeightUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: GradualWeightUpdate_filter
  ): [GradualWeightUpdate!]
  wrappedIndex: Int
  z: BigDecimal
}

type PoolContract {
  id: ID!
  pool: Pool!
}

input PoolContract_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [PoolContract_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [PoolContract_filter]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
}

enum PoolContract_orderBy {
  id
  pool
  pool__address
  pool__alpha
  pool__amp
  pool__baseToken
  pool__beta
  pool__c
  pool__createTime
  pool__dSq
  pool__delta
  pool__epsilon
  pool__expiryTime
  pool__factory
  pool__holdersCount
  pool__id
  pool__isInRecoveryMode
  pool__isPaused
  pool__joinExitEnabled
  pool__lambda
  pool__lastJoinExitAmp
  pool__lastPostJoinExitInvariant
  pool__lowerTarget
  pool__mainIndex
  pool__managementAumFee
  pool__managementFee
  pool__mustAllowlistLPs
  pool__name
  pool__oracleEnabled
  pool__owner
  pool__poolType
  pool__poolTypeVersion
  pool__principalToken
  pool__protocolAumFeeCache
  pool__protocolId
  pool__protocolSwapFeeCache
  pool__protocolYieldFeeCache
  pool__root3Alpha
  pool__s
  pool__sqrtAlpha
  pool__sqrtBeta
  pool__strategyType
  pool__swapEnabled
  pool__swapEnabledCurationSignal
  pool__swapEnabledInternal
  pool__swapFee
  pool__swapsCount
  pool__symbol
  pool__tauAlphaX
  pool__tauAlphaY
  pool__tauBetaX
  pool__tauBetaY
  pool__totalAumFeeCollectedInBPT
  pool__totalLiquidity
  pool__totalLiquiditySansBPT
  pool__totalProtocolFee
  pool__totalProtocolFeePaidInBPT
  pool__totalShares
  pool__totalSwapFee
  pool__totalSwapVolume
  pool__totalWeight
  pool__tx
  pool__u
  pool__unitSeconds
  pool__upperTarget
  pool__v
  pool__w
  pool__wrappedIndex
  pool__z
}

type PoolHistoricalLiquidity {
  block: BigInt!
  id: ID!
  poolId: Pool!
  poolLiquidity: BigDecimal!
  poolShareValue: BigDecimal!
  poolTotalShares: BigDecimal!
  pricingAsset: Bytes!
}

input PoolHistoricalLiquidity_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [PoolHistoricalLiquidity_filter]
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [PoolHistoricalLiquidity_filter]
  poolId: String
  poolId_: Pool_filter
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  poolLiquidity: BigDecimal
  poolLiquidity_gt: BigDecimal
  poolLiquidity_gte: BigDecimal
  poolLiquidity_in: [BigDecimal!]
  poolLiquidity_lt: BigDecimal
  poolLiquidity_lte: BigDecimal
  poolLiquidity_not: BigDecimal
  poolLiquidity_not_in: [BigDecimal!]
  poolShareValue: BigDecimal
  poolShareValue_gt: BigDecimal
  poolShareValue_gte: BigDecimal
  poolShareValue_in: [BigDecimal!]
  poolShareValue_lt: BigDecimal
  poolShareValue_lte: BigDecimal
  poolShareValue_not: BigDecimal
  poolShareValue_not_in: [BigDecimal!]
  poolTotalShares: BigDecimal
  poolTotalShares_gt: BigDecimal
  poolTotalShares_gte: BigDecimal
  poolTotalShares_in: [BigDecimal!]
  poolTotalShares_lt: BigDecimal
  poolTotalShares_lte: BigDecimal
  poolTotalShares_not: BigDecimal
  poolTotalShares_not_in: [BigDecimal!]
  pricingAsset: Bytes
  pricingAsset_contains: Bytes
  pricingAsset_gt: Bytes
  pricingAsset_gte: Bytes
  pricingAsset_in: [Bytes!]
  pricingAsset_lt: Bytes
  pricingAsset_lte: Bytes
  pricingAsset_not: Bytes
  pricingAsset_not_contains: Bytes
  pricingAsset_not_in: [Bytes!]
}

enum PoolHistoricalLiquidity_orderBy {
  block
  id
  poolId
  poolId__address
  poolId__alpha
  poolId__amp
  poolId__baseToken
  poolId__beta
  poolId__c
  poolId__createTime
  poolId__dSq
  poolId__delta
  poolId__epsilon
  poolId__expiryTime
  poolId__factory
  poolId__holdersCount
  poolId__id
  poolId__isInRecoveryMode
  poolId__isPaused
  poolId__joinExitEnabled
  poolId__lambda
  poolId__lastJoinExitAmp
  poolId__lastPostJoinExitInvariant
  poolId__lowerTarget
  poolId__mainIndex
  poolId__managementAumFee
  poolId__managementFee
  poolId__mustAllowlistLPs
  poolId__name
  poolId__oracleEnabled
  poolId__owner
  poolId__poolType
  poolId__poolTypeVersion
  poolId__principalToken
  poolId__protocolAumFeeCache
  poolId__protocolId
  poolId__protocolSwapFeeCache
  poolId__protocolYieldFeeCache
  poolId__root3Alpha
  poolId__s
  poolId__sqrtAlpha
  poolId__sqrtBeta
  poolId__strategyType
  poolId__swapEnabled
  poolId__swapEnabledCurationSignal
  poolId__swapEnabledInternal
  poolId__swapFee
  poolId__swapsCount
  poolId__symbol
  poolId__tauAlphaX
  poolId__tauAlphaY
  poolId__tauBetaX
  poolId__tauBetaY
  poolId__totalAumFeeCollectedInBPT
  poolId__totalLiquidity
  poolId__totalLiquiditySansBPT
  poolId__totalProtocolFee
  poolId__totalProtocolFeePaidInBPT
  poolId__totalShares
  poolId__totalSwapFee
  poolId__totalSwapVolume
  poolId__totalWeight
  poolId__tx
  poolId__u
  poolId__unitSeconds
  poolId__upperTarget
  poolId__v
  poolId__w
  poolId__wrappedIndex
  poolId__z
  poolLiquidity
  poolShareValue
  poolTotalShares
  pricingAsset
}

type PoolShare {
  balance: BigDecimal!
  id: ID!
  poolId: Pool!
  userAddress: User!
}

input PoolShare_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [PoolShare_filter]
  balance: BigDecimal
  balance_gt: BigDecimal
  balance_gte: BigDecimal
  balance_in: [BigDecimal!]
  balance_lt: BigDecimal
  balance_lte: BigDecimal
  balance_not: BigDecimal
  balance_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [PoolShare_filter]
  poolId: String
  poolId_: Pool_filter
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  userAddress: String
  userAddress_: User_filter
  userAddress_contains: String
  userAddress_contains_nocase: String
  userAddress_ends_with: String
  userAddress_ends_with_nocase: String
  userAddress_gt: String
  userAddress_gte: String
  userAddress_in: [String!]
  userAddress_lt: String
  userAddress_lte: String
  userAddress_not: String
  userAddress_not_contains: String
  userAddress_not_contains_nocase: String
  userAddress_not_ends_with: String
  userAddress_not_ends_with_nocase: String
  userAddress_not_in: [String!]
  userAddress_not_starts_with: String
  userAddress_not_starts_with_nocase: String
  userAddress_starts_with: String
  userAddress_starts_with_nocase: String
}

enum PoolShare_orderBy {
  balance
  id
  poolId
  poolId__address
  poolId__alpha
  poolId__amp
  poolId__baseToken
  poolId__beta
  poolId__c
  poolId__createTime
  poolId__dSq
  poolId__delta
  poolId__epsilon
  poolId__expiryTime
  poolId__factory
  poolId__holdersCount
  poolId__id
  poolId__isInRecoveryMode
  poolId__isPaused
  poolId__joinExitEnabled
  poolId__lambda
  poolId__lastJoinExitAmp
  poolId__lastPostJoinExitInvariant
  poolId__lowerTarget
  poolId__mainIndex
  poolId__managementAumFee
  poolId__managementFee
  poolId__mustAllowlistLPs
  poolId__name
  poolId__oracleEnabled
  poolId__owner
  poolId__poolType
  poolId__poolTypeVersion
  poolId__principalToken
  poolId__protocolAumFeeCache
  poolId__protocolId
  poolId__protocolSwapFeeCache
  poolId__protocolYieldFeeCache
  poolId__root3Alpha
  poolId__s
  poolId__sqrtAlpha
  poolId__sqrtBeta
  poolId__strategyType
  poolId__swapEnabled
  poolId__swapEnabledCurationSignal
  poolId__swapEnabledInternal
  poolId__swapFee
  poolId__swapsCount
  poolId__symbol
  poolId__tauAlphaX
  poolId__tauAlphaY
  poolId__tauBetaX
  poolId__tauBetaY
  poolId__totalAumFeeCollectedInBPT
  poolId__totalLiquidity
  poolId__totalLiquiditySansBPT
  poolId__totalProtocolFee
  poolId__totalProtocolFeePaidInBPT
  poolId__totalShares
  poolId__totalSwapFee
  poolId__totalSwapVolume
  poolId__totalWeight
  poolId__tx
  poolId__u
  poolId__unitSeconds
  poolId__upperTarget
  poolId__v
  poolId__w
  poolId__wrappedIndex
  poolId__z
  userAddress
  userAddress__id
}

type PoolSnapshot {
  amounts: [BigDecimal!]!
  holdersCount: BigInt!
  id: ID!
  liquidity: BigDecimal!
  pool: Pool!
  protocolFee: BigDecimal
  swapFees: BigDecimal!
  swapVolume: BigDecimal!
  swapsCount: BigInt!
  timestamp: Int!
  totalShares: BigDecimal!
}

input PoolSnapshot_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amounts: [BigDecimal!]
  amounts_contains: [BigDecimal!]
  amounts_contains_nocase: [BigDecimal!]
  amounts_not: [BigDecimal!]
  amounts_not_contains: [BigDecimal!]
  amounts_not_contains_nocase: [BigDecimal!]
  and: [PoolSnapshot_filter]
  holdersCount: BigInt
  holdersCount_gt: BigInt
  holdersCount_gte: BigInt
  holdersCount_in: [BigInt!]
  holdersCount_lt: BigInt
  holdersCount_lte: BigInt
  holdersCount_not: BigInt
  holdersCount_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  liquidity: BigDecimal
  liquidity_gt: BigDecimal
  liquidity_gte: BigDecimal
  liquidity_in: [BigDecimal!]
  liquidity_lt: BigDecimal
  liquidity_lte: BigDecimal
  liquidity_not: BigDecimal
  liquidity_not_in: [BigDecimal!]
  or: [PoolSnapshot_filter]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  protocolFee: BigDecimal
  protocolFee_gt: BigDecimal
  protocolFee_gte: BigDecimal
  protocolFee_in: [BigDecimal!]
  protocolFee_lt: BigDecimal
  protocolFee_lte: BigDecimal
  protocolFee_not: BigDecimal
  protocolFee_not_in: [BigDecimal!]
  swapFees: BigDecimal
  swapFees_gt: BigDecimal
  swapFees_gte: BigDecimal
  swapFees_in: [BigDecimal!]
  swapFees_lt: BigDecimal
  swapFees_lte: BigDecimal
  swapFees_not: BigDecimal
  swapFees_not_in: [BigDecimal!]
  swapVolume: BigDecimal
  swapVolume_gt: BigDecimal
  swapVolume_gte: BigDecimal
  swapVolume_in: [BigDecimal!]
  swapVolume_lt: BigDecimal
  swapVolume_lte: BigDecimal
  swapVolume_not: BigDecimal
  swapVolume_not_in: [BigDecimal!]
  swapsCount: BigInt
  swapsCount_gt: BigInt
  swapsCount_gte: BigInt
  swapsCount_in: [BigInt!]
  swapsCount_lt: BigInt
  swapsCount_lte: BigInt
  swapsCount_not: BigInt
  swapsCount_not_in: [BigInt!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  totalShares: BigDecimal
  totalShares_gt: BigDecimal
  totalShares_gte: BigDecimal
  totalShares_in: [BigDecimal!]
  totalShares_lt: BigDecimal
  totalShares_lte: BigDecimal
  totalShares_not: BigDecimal
  totalShares_not_in: [BigDecimal!]
}

enum PoolSnapshot_orderBy {
  amounts
  holdersCount
  id
  liquidity
  pool
  pool__address
  pool__alpha
  pool__amp
  pool__baseToken
  pool__beta
  pool__c
  pool__createTime
  pool__dSq
  pool__delta
  pool__epsilon
  pool__expiryTime
  pool__factory
  pool__holdersCount
  pool__id
  pool__isInRecoveryMode
  pool__isPaused
  pool__joinExitEnabled
  pool__lambda
  pool__lastJoinExitAmp
  pool__lastPostJoinExitInvariant
  pool__lowerTarget
  pool__mainIndex
  pool__managementAumFee
  pool__managementFee
  pool__mustAllowlistLPs
  pool__name
  pool__oracleEnabled
  pool__owner
  pool__poolType
  pool__poolTypeVersion
  pool__principalToken
  pool__protocolAumFeeCache
  pool__protocolId
  pool__protocolSwapFeeCache
  pool__protocolYieldFeeCache
  pool__root3Alpha
  pool__s
  pool__sqrtAlpha
  pool__sqrtBeta
  pool__strategyType
  pool__swapEnabled
  pool__swapEnabledCurationSignal
  pool__swapEnabledInternal
  pool__swapFee
  pool__swapsCount
  pool__symbol
  pool__tauAlphaX
  pool__tauAlphaY
  pool__tauBetaX
  pool__tauBetaY
  pool__totalAumFeeCollectedInBPT
  pool__totalLiquidity
  pool__totalLiquiditySansBPT
  pool__totalProtocolFee
  pool__totalProtocolFeePaidInBPT
  pool__totalShares
  pool__totalSwapFee
  pool__totalSwapVolume
  pool__totalWeight
  pool__tx
  pool__u
  pool__unitSeconds
  pool__upperTarget
  pool__v
  pool__w
  pool__wrappedIndex
  pool__z
  protocolFee
  swapFees
  swapVolume
  swapsCount
  timestamp
  totalShares
}

type PoolToken {
  address: String!
  assetManager: Bytes!
  balance: BigDecimal!
  cashBalance: BigDecimal!
  circuitBreaker: CircuitBreaker
  decimals: Int!
  id: ID!
  index: Int
  isExemptFromYieldProtocolFee: Boolean
  managedBalance: BigDecimal!
  managements(
    first: Int = 100
    orderBy: ManagementOperation_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: ManagementOperation_filter
  ): [ManagementOperation!]
  name: String!
  oldPriceRate: BigDecimal
  paidProtocolFees: BigDecimal
  poolId: Pool
  priceRate: BigDecimal!
  symbol: String!
  token: Token!
  weight: BigDecimal
}

input PoolToken_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  address: String
  address_contains: String
  address_contains_nocase: String
  address_ends_with: String
  address_ends_with_nocase: String
  address_gt: String
  address_gte: String
  address_in: [String!]
  address_lt: String
  address_lte: String
  address_not: String
  address_not_contains: String
  address_not_contains_nocase: String
  address_not_ends_with: String
  address_not_ends_with_nocase: String
  address_not_in: [String!]
  address_not_starts_with: String
  address_not_starts_with_nocase: String
  address_starts_with: String
  address_starts_with_nocase: String
  and: [PoolToken_filter]
  assetManager: Bytes
  assetManager_contains: Bytes
  assetManager_gt: Bytes
  assetManager_gte: Bytes
  assetManager_in: [Bytes!]
  assetManager_lt: Bytes
  assetManager_lte: Bytes
  assetManager_not: Bytes
  assetManager_not_contains: Bytes
  assetManager_not_in: [Bytes!]
  balance: BigDecimal
  balance_gt: BigDecimal
  balance_gte: BigDecimal
  balance_in: [BigDecimal!]
  balance_lt: BigDecimal
  balance_lte: BigDecimal
  balance_not: BigDecimal
  balance_not_in: [BigDecimal!]
  cashBalance: BigDecimal
  cashBalance_gt: BigDecimal
  cashBalance_gte: BigDecimal
  cashBalance_in: [BigDecimal!]
  cashBalance_lt: BigDecimal
  cashBalance_lte: BigDecimal
  cashBalance_not: BigDecimal
  cashBalance_not_in: [BigDecimal!]
  circuitBreaker: String
  circuitBreaker_: CircuitBreaker_filter
  circuitBreaker_contains: String
  circuitBreaker_contains_nocase: String
  circuitBreaker_ends_with: String
  circuitBreaker_ends_with_nocase: String
  circuitBreaker_gt: String
  circuitBreaker_gte: String
  circuitBreaker_in: [String!]
  circuitBreaker_lt: String
  circuitBreaker_lte: String
  circuitBreaker_not: String
  circuitBreaker_not_contains: String
  circuitBreaker_not_contains_nocase: String
  circuitBreaker_not_ends_with: String
  circuitBreaker_not_ends_with_nocase: String
  circuitBreaker_not_in: [String!]
  circuitBreaker_not_starts_with: String
  circuitBreaker_not_starts_with_nocase: String
  circuitBreaker_starts_with: String
  circuitBreaker_starts_with_nocase: String
  decimals: Int
  decimals_gt: Int
  decimals_gte: Int
  decimals_in: [Int!]
  decimals_lt: Int
  decimals_lte: Int
  decimals_not: Int
  decimals_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  index: Int
  index_gt: Int
  index_gte: Int
  index_in: [Int!]
  index_lt: Int
  index_lte: Int
  index_not: Int
  index_not_in: [Int!]
  isExemptFromYieldProtocolFee: Boolean
  isExemptFromYieldProtocolFee_in: [Boolean!]
  isExemptFromYieldProtocolFee_not: Boolean
  isExemptFromYieldProtocolFee_not_in: [Boolean!]
  managedBalance: BigDecimal
  managedBalance_gt: BigDecimal
  managedBalance_gte: BigDecimal
  managedBalance_in: [BigDecimal!]
  managedBalance_lt: BigDecimal
  managedBalance_lte: BigDecimal
  managedBalance_not: BigDecimal
  managedBalance_not_in: [BigDecimal!]
  managements_: ManagementOperation_filter
  name: String
  name_contains: String
  name_contains_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  oldPriceRate: BigDecimal
  oldPriceRate_gt: BigDecimal
  oldPriceRate_gte: BigDecimal
  oldPriceRate_in: [BigDecimal!]
  oldPriceRate_lt: BigDecimal
  oldPriceRate_lte: BigDecimal
  oldPriceRate_not: BigDecimal
  oldPriceRate_not_in: [BigDecimal!]
  or: [PoolToken_filter]
  paidProtocolFees: BigDecimal
  paidProtocolFees_gt: BigDecimal
  paidProtocolFees_gte: BigDecimal
  paidProtocolFees_in: [BigDecimal!]
  paidProtocolFees_lt: BigDecimal
  paidProtocolFees_lte: BigDecimal
  paidProtocolFees_not: BigDecimal
  paidProtocolFees_not_in: [BigDecimal!]
  poolId: String
  poolId_: Pool_filter
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  priceRate: BigDecimal
  priceRate_gt: BigDecimal
  priceRate_gte: BigDecimal
  priceRate_in: [BigDecimal!]
  priceRate_lt: BigDecimal
  priceRate_lte: BigDecimal
  priceRate_not: BigDecimal
  priceRate_not_in: [BigDecimal!]
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  weight: BigDecimal
  weight_gt: BigDecimal
  weight_gte: BigDecimal
  weight_in: [BigDecimal!]
  weight_lt: BigDecimal
  weight_lte: BigDecimal
  weight_not: BigDecimal
  weight_not_in: [BigDecimal!]
}

enum PoolToken_orderBy {
  address
  assetManager
  balance
  cashBalance
  circuitBreaker
  circuitBreaker__bptPrice
  circuitBreaker__id
  circuitBreaker__lowerBoundPercentage
  circuitBreaker__upperBoundPercentage
  decimals
  id
  index
  isExemptFromYieldProtocolFee
  managedBalance
  managements
  name
  oldPriceRate
  paidProtocolFees
  poolId
  poolId__address
  poolId__alpha
  poolId__amp
  poolId__baseToken
  poolId__beta
  poolId__c
  poolId__createTime
  poolId__dSq
  poolId__delta
  poolId__epsilon
  poolId__expiryTime
  poolId__factory
  poolId__holdersCount
  poolId__id
  poolId__isInRecoveryMode
  poolId__isPaused
  poolId__joinExitEnabled
  poolId__lambda
  poolId__lastJoinExitAmp
  poolId__lastPostJoinExitInvariant
  poolId__lowerTarget
  poolId__mainIndex
  poolId__managementAumFee
  poolId__managementFee
  poolId__mustAllowlistLPs
  poolId__name
  poolId__oracleEnabled
  poolId__owner
  poolId__poolType
  poolId__poolTypeVersion
  poolId__principalToken
  poolId__protocolAumFeeCache
  poolId__protocolId
  poolId__protocolSwapFeeCache
  poolId__protocolYieldFeeCache
  poolId__root3Alpha
  poolId__s
  poolId__sqrtAlpha
  poolId__sqrtBeta
  poolId__strategyType
  poolId__swapEnabled
  poolId__swapEnabledCurationSignal
  poolId__swapEnabledInternal
  poolId__swapFee
  poolId__swapsCount
  poolId__symbol
  poolId__tauAlphaX
  poolId__tauAlphaY
  poolId__tauBetaX
  poolId__tauBetaY
  poolId__totalAumFeeCollectedInBPT
  poolId__totalLiquidity
  poolId__totalLiquiditySansBPT
  poolId__totalProtocolFee
  poolId__totalProtocolFeePaidInBPT
  poolId__totalShares
  poolId__totalSwapFee
  poolId__totalSwapVolume
  poolId__totalWeight
  poolId__tx
  poolId__u
  poolId__unitSeconds
  poolId__upperTarget
  poolId__v
  poolId__w
  poolId__wrappedIndex
  poolId__z
  priceRate
  symbol
  token
  token__address
  token__decimals
  token__fxOracleDecimals
  token__id
  token__latestFXPrice
  token__latestUSDPrice
  token__latestUSDPriceTimestamp
  token__name
  token__symbol
  token__totalBalanceNotional
  token__totalBalanceUSD
  token__totalSwapCount
  token__totalVolumeNotional
  token__totalVolumeUSD
  weight
}

input Pool_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  address: Bytes
  address_contains: Bytes
  address_gt: Bytes
  address_gte: Bytes
  address_in: [Bytes!]
  address_lt: Bytes
  address_lte: Bytes
  address_not: Bytes
  address_not_contains: Bytes
  address_not_in: [Bytes!]
  alpha: BigDecimal
  alpha_gt: BigDecimal
  alpha_gte: BigDecimal
  alpha_in: [BigDecimal!]
  alpha_lt: BigDecimal
  alpha_lte: BigDecimal
  alpha_not: BigDecimal
  alpha_not_in: [BigDecimal!]
  amp: BigInt
  ampUpdates_: AmpUpdate_filter
  amp_gt: BigInt
  amp_gte: BigInt
  amp_in: [BigInt!]
  amp_lt: BigInt
  amp_lte: BigInt
  amp_not: BigInt
  amp_not_in: [BigInt!]
  and: [Pool_filter]
  baseToken: Bytes
  baseToken_contains: Bytes
  baseToken_gt: Bytes
  baseToken_gte: Bytes
  baseToken_in: [Bytes!]
  baseToken_lt: Bytes
  baseToken_lte: Bytes
  baseToken_not: Bytes
  baseToken_not_contains: Bytes
  baseToken_not_in: [Bytes!]
  beta: BigDecimal
  beta_gt: BigDecimal
  beta_gte: BigDecimal
  beta_in: [BigDecimal!]
  beta_lt: BigDecimal
  beta_lte: BigDecimal
  beta_not: BigDecimal
  beta_not_in: [BigDecimal!]
  c: BigDecimal
  c_gt: BigDecimal
  c_gte: BigDecimal
  c_in: [BigDecimal!]
  c_lt: BigDecimal
  c_lte: BigDecimal
  c_not: BigDecimal
  c_not_in: [BigDecimal!]
  circuitBreakers_: CircuitBreaker_filter
  createTime: Int
  createTime_gt: Int
  createTime_gte: Int
  createTime_in: [Int!]
  createTime_lt: Int
  createTime_lte: Int
  createTime_not: Int
  createTime_not_in: [Int!]
  dSq: BigDecimal
  dSq_gt: BigDecimal
  dSq_gte: BigDecimal
  dSq_in: [BigDecimal!]
  dSq_lt: BigDecimal
  dSq_lte: BigDecimal
  dSq_not: BigDecimal
  dSq_not_in: [BigDecimal!]
  delta: BigDecimal
  delta_gt: BigDecimal
  delta_gte: BigDecimal
  delta_in: [BigDecimal!]
  delta_lt: BigDecimal
  delta_lte: BigDecimal
  delta_not: BigDecimal
  delta_not_in: [BigDecimal!]
  epsilon: BigDecimal
  epsilon_gt: BigDecimal
  epsilon_gte: BigDecimal
  epsilon_in: [BigDecimal!]
  epsilon_lt: BigDecimal
  epsilon_lte: BigDecimal
  epsilon_not: BigDecimal
  epsilon_not_in: [BigDecimal!]
  expiryTime: BigInt
  expiryTime_gt: BigInt
  expiryTime_gte: BigInt
  expiryTime_in: [BigInt!]
  expiryTime_lt: BigInt
  expiryTime_lte: BigInt
  expiryTime_not: BigInt
  expiryTime_not_in: [BigInt!]
  factory: Bytes
  factory_contains: Bytes
  factory_gt: Bytes
  factory_gte: Bytes
  factory_in: [Bytes!]
  factory_lt: Bytes
  factory_lte: Bytes
  factory_not: Bytes
  factory_not_contains: Bytes
  factory_not_in: [Bytes!]
  gaugesList: [Bytes!]
  gaugesList_contains: [Bytes!]
  gaugesList_contains_nocase: [Bytes!]
  gaugesList_not: [Bytes!]
  gaugesList_not_contains: [Bytes!]
  gaugesList_not_contains_nocase: [Bytes!]
  gauges_: LiquidityGauge_filter
  historicalValues_: PoolHistoricalLiquidity_filter
  holdersCount: BigInt
  holdersCount_gt: BigInt
  holdersCount_gte: BigInt
  holdersCount_in: [BigInt!]
  holdersCount_lt: BigInt
  holdersCount_lte: BigInt
  holdersCount_not: BigInt
  holdersCount_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isInRecoveryMode: Boolean
  isInRecoveryMode_in: [Boolean!]
  isInRecoveryMode_not: Boolean
  isInRecoveryMode_not_in: [Boolean!]
  isPaused: Boolean
  isPaused_in: [Boolean!]
  isPaused_not: Boolean
  isPaused_not_in: [Boolean!]
  joinExitEnabled: Boolean
  joinExitEnabled_in: [Boolean!]
  joinExitEnabled_not: Boolean
  joinExitEnabled_not_in: [Boolean!]
  joinsExits_: JoinExit_filter
  lambda: BigDecimal
  lambda_gt: BigDecimal
  lambda_gte: BigDecimal
  lambda_in: [BigDecimal!]
  lambda_lt: BigDecimal
  lambda_lte: BigDecimal
  lambda_not: BigDecimal
  lambda_not_in: [BigDecimal!]
  lastJoinExitAmp: BigInt
  lastJoinExitAmp_gt: BigInt
  lastJoinExitAmp_gte: BigInt
  lastJoinExitAmp_in: [BigInt!]
  lastJoinExitAmp_lt: BigInt
  lastJoinExitAmp_lte: BigInt
  lastJoinExitAmp_not: BigInt
  lastJoinExitAmp_not_in: [BigInt!]
  lastPostJoinExitInvariant: BigDecimal
  lastPostJoinExitInvariant_gt: BigDecimal
  lastPostJoinExitInvariant_gte: BigDecimal
  lastPostJoinExitInvariant_in: [BigDecimal!]
  lastPostJoinExitInvariant_lt: BigDecimal
  lastPostJoinExitInvariant_lte: BigDecimal
  lastPostJoinExitInvariant_not: BigDecimal
  lastPostJoinExitInvariant_not_in: [BigDecimal!]
  latestAmpUpdate: String
  latestAmpUpdate_: AmpUpdate_filter
  latestAmpUpdate_contains: String
  latestAmpUpdate_contains_nocase: String
  latestAmpUpdate_ends_with: String
  latestAmpUpdate_ends_with_nocase: String
  latestAmpUpdate_gt: String
  latestAmpUpdate_gte: String
  latestAmpUpdate_in: [String!]
  latestAmpUpdate_lt: String
  latestAmpUpdate_lte: String
  latestAmpUpdate_not: String
  latestAmpUpdate_not_contains: String
  latestAmpUpdate_not_contains_nocase: String
  latestAmpUpdate_not_ends_with: String
  latestAmpUpdate_not_ends_with_nocase: String
  latestAmpUpdate_not_in: [String!]
  latestAmpUpdate_not_starts_with: String
  latestAmpUpdate_not_starts_with_nocase: String
  latestAmpUpdate_starts_with: String
  latestAmpUpdate_starts_with_nocase: String
  lowerTarget: BigDecimal
  lowerTarget_gt: BigDecimal
  lowerTarget_gte: BigDecimal
  lowerTarget_in: [BigDecimal!]
  lowerTarget_lt: BigDecimal
  lowerTarget_lte: BigDecimal
  lowerTarget_not: BigDecimal
  lowerTarget_not_in: [BigDecimal!]
  mainIndex: Int
  mainIndex_gt: Int
  mainIndex_gte: Int
  mainIndex_in: [Int!]
  mainIndex_lt: Int
  mainIndex_lte: Int
  mainIndex_not: Int
  mainIndex_not_in: [Int!]
  managementAumFee: BigDecimal
  managementAumFee_gt: BigDecimal
  managementAumFee_gte: BigDecimal
  managementAumFee_in: [BigDecimal!]
  managementAumFee_lt: BigDecimal
  managementAumFee_lte: BigDecimal
  managementAumFee_not: BigDecimal
  managementAumFee_not_in: [BigDecimal!]
  managementFee: BigDecimal
  managementFee_gt: BigDecimal
  managementFee_gte: BigDecimal
  managementFee_in: [BigDecimal!]
  managementFee_lt: BigDecimal
  managementFee_lte: BigDecimal
  managementFee_not: BigDecimal
  managementFee_not_in: [BigDecimal!]
  mustAllowlistLPs: Boolean
  mustAllowlistLPs_in: [Boolean!]
  mustAllowlistLPs_not: Boolean
  mustAllowlistLPs_not_in: [Boolean!]
  name: String
  name_contains: String
  name_contains_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  or: [Pool_filter]
  oracleEnabled: Boolean
  oracleEnabled_in: [Boolean!]
  oracleEnabled_not: Boolean
  oracleEnabled_not_in: [Boolean!]
  owner: Bytes
  owner_contains: Bytes
  owner_gt: Bytes
  owner_gte: Bytes
  owner_in: [Bytes!]
  owner_lt: Bytes
  owner_lte: Bytes
  owner_not: Bytes
  owner_not_contains: Bytes
  owner_not_in: [Bytes!]
  poolId: Bytes
  poolId_contains: Bytes
  poolId_gt: Bytes
  poolId_gte: Bytes
  poolId_in: [Bytes!]
  poolId_lt: Bytes
  poolId_lte: Bytes
  poolId_not: Bytes
  poolId_not_contains: Bytes
  poolId_not_in: [Bytes!]
  poolType: String
  poolTypeVersion: Int
  poolTypeVersion_gt: Int
  poolTypeVersion_gte: Int
  poolTypeVersion_in: [Int!]
  poolTypeVersion_lt: Int
  poolTypeVersion_lte: Int
  poolTypeVersion_not: Int
  poolTypeVersion_not_in: [Int!]
  poolType_contains: String
  poolType_contains_nocase: String
  poolType_ends_with: String
  poolType_ends_with_nocase: String
  poolType_gt: String
  poolType_gte: String
  poolType_in: [String!]
  poolType_lt: String
  poolType_lte: String
  poolType_not: String
  poolType_not_contains: String
  poolType_not_contains_nocase: String
  poolType_not_ends_with: String
  poolType_not_ends_with_nocase: String
  poolType_not_in: [String!]
  poolType_not_starts_with: String
  poolType_not_starts_with_nocase: String
  poolType_starts_with: String
  poolType_starts_with_nocase: String
  preferentialGauge: String
  preferentialGauge_: LiquidityGauge_filter
  preferentialGauge_contains: String
  preferentialGauge_contains_nocase: String
  preferentialGauge_ends_with: String
  preferentialGauge_ends_with_nocase: String
  preferentialGauge_gt: String
  preferentialGauge_gte: String
  preferentialGauge_in: [String!]
  preferentialGauge_lt: String
  preferentialGauge_lte: String
  preferentialGauge_not: String
  preferentialGauge_not_contains: String
  preferentialGauge_not_contains_nocase: String
  preferentialGauge_not_ends_with: String
  preferentialGauge_not_ends_with_nocase: String
  preferentialGauge_not_in: [String!]
  preferentialGauge_not_starts_with: String
  preferentialGauge_not_starts_with_nocase: String
  preferentialGauge_starts_with: String
  preferentialGauge_starts_with_nocase: String
  priceRateProviders_: PriceRateProvider_filter
  principalToken: Bytes
  principalToken_contains: Bytes
  principalToken_gt: Bytes
  principalToken_gte: Bytes
  principalToken_in: [Bytes!]
  principalToken_lt: Bytes
  principalToken_lte: Bytes
  principalToken_not: Bytes
  principalToken_not_contains: Bytes
  principalToken_not_in: [Bytes!]
  protocolAumFeeCache: BigDecimal
  protocolAumFeeCache_gt: BigDecimal
  protocolAumFeeCache_gte: BigDecimal
  protocolAumFeeCache_in: [BigDecimal!]
  protocolAumFeeCache_lt: BigDecimal
  protocolAumFeeCache_lte: BigDecimal
  protocolAumFeeCache_not: BigDecimal
  protocolAumFeeCache_not_in: [BigDecimal!]
  protocolId: Int
  protocolIdData: String
  protocolIdData_: ProtocolIdData_filter
  protocolIdData_contains: String
  protocolIdData_contains_nocase: String
  protocolIdData_ends_with: String
  protocolIdData_ends_with_nocase: String
  protocolIdData_gt: String
  protocolIdData_gte: String
  protocolIdData_in: [String!]
  protocolIdData_lt: String
  protocolIdData_lte: String
  protocolIdData_not: String
  protocolIdData_not_contains: String
  protocolIdData_not_contains_nocase: String
  protocolIdData_not_ends_with: String
  protocolIdData_not_ends_with_nocase: String
  protocolIdData_not_in: [String!]
  protocolIdData_not_starts_with: String
  protocolIdData_not_starts_with_nocase: String
  protocolIdData_starts_with: String
  protocolIdData_starts_with_nocase: String
  protocolId_gt: Int
  protocolId_gte: Int
  protocolId_in: [Int!]
  protocolId_lt: Int
  protocolId_lte: Int
  protocolId_not: Int
  protocolId_not_in: [Int!]
  protocolSwapFeeCache: BigDecimal
  protocolSwapFeeCache_gt: BigDecimal
  protocolSwapFeeCache_gte: BigDecimal
  protocolSwapFeeCache_in: [BigDecimal!]
  protocolSwapFeeCache_lt: BigDecimal
  protocolSwapFeeCache_lte: BigDecimal
  protocolSwapFeeCache_not: BigDecimal
  protocolSwapFeeCache_not_in: [BigDecimal!]
  protocolYieldFeeCache: BigDecimal
  protocolYieldFeeCache_gt: BigDecimal
  protocolYieldFeeCache_gte: BigDecimal
  protocolYieldFeeCache_in: [BigDecimal!]
  protocolYieldFeeCache_lt: BigDecimal
  protocolYieldFeeCache_lte: BigDecimal
  protocolYieldFeeCache_not: BigDecimal
  protocolYieldFeeCache_not_in: [BigDecimal!]
  root3Alpha: BigDecimal
  root3Alpha_gt: BigDecimal
  root3Alpha_gte: BigDecimal
  root3Alpha_in: [BigDecimal!]
  root3Alpha_lt: BigDecimal
  root3Alpha_lte: BigDecimal
  root3Alpha_not: BigDecimal
  root3Alpha_not_in: [BigDecimal!]
  s: BigDecimal
  s_gt: BigDecimal
  s_gte: BigDecimal
  s_in: [BigDecimal!]
  s_lt: BigDecimal
  s_lte: BigDecimal
  s_not: BigDecimal
  s_not_in: [BigDecimal!]
  shares_: PoolShare_filter
  snapshots_: PoolSnapshot_filter
  sqrtAlpha: BigDecimal
  sqrtAlpha_gt: BigDecimal
  sqrtAlpha_gte: BigDecimal
  sqrtAlpha_in: [BigDecimal!]
  sqrtAlpha_lt: BigDecimal
  sqrtAlpha_lte: BigDecimal
  sqrtAlpha_not: BigDecimal
  sqrtAlpha_not_in: [BigDecimal!]
  sqrtBeta: BigDecimal
  sqrtBeta_gt: BigDecimal
  sqrtBeta_gte: BigDecimal
  sqrtBeta_in: [BigDecimal!]
  sqrtBeta_lt: BigDecimal
  sqrtBeta_lte: BigDecimal
  sqrtBeta_not: BigDecimal
  sqrtBeta_not_in: [BigDecimal!]
  strategyType: Int
  strategyType_gt: Int
  strategyType_gte: Int
  strategyType_in: [Int!]
  strategyType_lt: Int
  strategyType_lte: Int
  strategyType_not: Int
  strategyType_not_in: [Int!]
  swapEnabled: Boolean
  swapEnabledCurationSignal: Boolean
  swapEnabledCurationSignal_in: [Boolean!]
  swapEnabledCurationSignal_not: Boolean
  swapEnabledCurationSignal_not_in: [Boolean!]
  swapEnabledInternal: Boolean
  swapEnabledInternal_in: [Boolean!]
  swapEnabledInternal_not: Boolean
  swapEnabledInternal_not_in: [Boolean!]
  swapEnabled_in: [Boolean!]
  swapEnabled_not: Boolean
  swapEnabled_not_in: [Boolean!]
  swapFee: BigDecimal
  swapFee_gt: BigDecimal
  swapFee_gte: BigDecimal
  swapFee_in: [BigDecimal!]
  swapFee_lt: BigDecimal
  swapFee_lte: BigDecimal
  swapFee_not: BigDecimal
  swapFee_not_in: [BigDecimal!]
  swapsCount: BigInt
  swapsCount_gt: BigInt
  swapsCount_gte: BigInt
  swapsCount_in: [BigInt!]
  swapsCount_lt: BigInt
  swapsCount_lte: BigInt
  swapsCount_not: BigInt
  swapsCount_not_in: [BigInt!]
  swaps_: Swap_filter
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  tauAlphaX: BigDecimal
  tauAlphaX_gt: BigDecimal
  tauAlphaX_gte: BigDecimal
  tauAlphaX_in: [BigDecimal!]
  tauAlphaX_lt: BigDecimal
  tauAlphaX_lte: BigDecimal
  tauAlphaX_not: BigDecimal
  tauAlphaX_not_in: [BigDecimal!]
  tauAlphaY: BigDecimal
  tauAlphaY_gt: BigDecimal
  tauAlphaY_gte: BigDecimal
  tauAlphaY_in: [BigDecimal!]
  tauAlphaY_lt: BigDecimal
  tauAlphaY_lte: BigDecimal
  tauAlphaY_not: BigDecimal
  tauAlphaY_not_in: [BigDecimal!]
  tauBetaX: BigDecimal
  tauBetaX_gt: BigDecimal
  tauBetaX_gte: BigDecimal
  tauBetaX_in: [BigDecimal!]
  tauBetaX_lt: BigDecimal
  tauBetaX_lte: BigDecimal
  tauBetaX_not: BigDecimal
  tauBetaX_not_in: [BigDecimal!]
  tauBetaY: BigDecimal
  tauBetaY_gt: BigDecimal
  tauBetaY_gte: BigDecimal
  tauBetaY_in: [BigDecimal!]
  tauBetaY_lt: BigDecimal
  tauBetaY_lte: BigDecimal
  tauBetaY_not: BigDecimal
  tauBetaY_not_in: [BigDecimal!]
  tokensList: [Bytes!]
  tokensList_contains: [Bytes!]
  tokensList_contains_nocase: [Bytes!]
  tokensList_not: [Bytes!]
  tokensList_not_contains: [Bytes!]
  tokensList_not_contains_nocase: [Bytes!]
  tokens_: PoolToken_filter
  totalAumFeeCollectedInBPT: BigDecimal
  totalAumFeeCollectedInBPT_gt: BigDecimal
  totalAumFeeCollectedInBPT_gte: BigDecimal
  totalAumFeeCollectedInBPT_in: [BigDecimal!]
  totalAumFeeCollectedInBPT_lt: BigDecimal
  totalAumFeeCollectedInBPT_lte: BigDecimal
  totalAumFeeCollectedInBPT_not: BigDecimal
  totalAumFeeCollectedInBPT_not_in: [BigDecimal!]
  totalLiquidity: BigDecimal
  totalLiquiditySansBPT: BigDecimal
  totalLiquiditySansBPT_gt: BigDecimal
  totalLiquiditySansBPT_gte: BigDecimal
  totalLiquiditySansBPT_in: [BigDecimal!]
  totalLiquiditySansBPT_lt: BigDecimal
  totalLiquiditySansBPT_lte: BigDecimal
  totalLiquiditySansBPT_not: BigDecimal
  totalLiquiditySansBPT_not_in: [BigDecimal!]
  totalLiquidity_gt: BigDecimal
  totalLiquidity_gte: BigDecimal
  totalLiquidity_in: [BigDecimal!]
  totalLiquidity_lt: BigDecimal
  totalLiquidity_lte: BigDecimal
  totalLiquidity_not: BigDecimal
  totalLiquidity_not_in: [BigDecimal!]
  totalProtocolFee: BigDecimal
  totalProtocolFeePaidInBPT: BigDecimal
  totalProtocolFeePaidInBPT_gt: BigDecimal
  totalProtocolFeePaidInBPT_gte: BigDecimal
  totalProtocolFeePaidInBPT_in: [BigDecimal!]
  totalProtocolFeePaidInBPT_lt: BigDecimal
  totalProtocolFeePaidInBPT_lte: BigDecimal
  totalProtocolFeePaidInBPT_not: BigDecimal
  totalProtocolFeePaidInBPT_not_in: [BigDecimal!]
  totalProtocolFee_gt: BigDecimal
  totalProtocolFee_gte: BigDecimal
  totalProtocolFee_in: [BigDecimal!]
  totalProtocolFee_lt: BigDecimal
  totalProtocolFee_lte: BigDecimal
  totalProtocolFee_not: BigDecimal
  totalProtocolFee_not_in: [BigDecimal!]
  totalShares: BigDecimal
  totalShares_gt: BigDecimal
  totalShares_gte: BigDecimal
  totalShares_in: [BigDecimal!]
  totalShares_lt: BigDecimal
  totalShares_lte: BigDecimal
  totalShares_not: BigDecimal
  totalShares_not_in: [BigDecimal!]
  totalSwapFee: BigDecimal
  totalSwapFee_gt: BigDecimal
  totalSwapFee_gte: BigDecimal
  totalSwapFee_in: [BigDecimal!]
  totalSwapFee_lt: BigDecimal
  totalSwapFee_lte: BigDecimal
  totalSwapFee_not: BigDecimal
  totalSwapFee_not_in: [BigDecimal!]
  totalSwapVolume: BigDecimal
  totalSwapVolume_gt: BigDecimal
  totalSwapVolume_gte: BigDecimal
  totalSwapVolume_in: [BigDecimal!]
  totalSwapVolume_lt: BigDecimal
  totalSwapVolume_lte: BigDecimal
  totalSwapVolume_not: BigDecimal
  totalSwapVolume_not_in: [BigDecimal!]
  totalWeight: BigDecimal
  totalWeight_gt: BigDecimal
  totalWeight_gte: BigDecimal
  totalWeight_in: [BigDecimal!]
  totalWeight_lt: BigDecimal
  totalWeight_lte: BigDecimal
  totalWeight_not: BigDecimal
  totalWeight_not_in: [BigDecimal!]
  tx: Bytes
  tx_contains: Bytes
  tx_gt: Bytes
  tx_gte: Bytes
  tx_in: [Bytes!]
  tx_lt: Bytes
  tx_lte: Bytes
  tx_not: Bytes
  tx_not_contains: Bytes
  tx_not_in: [Bytes!]
  u: BigDecimal
  u_gt: BigDecimal
  u_gte: BigDecimal
  u_in: [BigDecimal!]
  u_lt: BigDecimal
  u_lte: BigDecimal
  u_not: BigDecimal
  u_not_in: [BigDecimal!]
  unitSeconds: BigInt
  unitSeconds_gt: BigInt
  unitSeconds_gte: BigInt
  unitSeconds_in: [BigInt!]
  unitSeconds_lt: BigInt
  unitSeconds_lte: BigInt
  unitSeconds_not: BigInt
  unitSeconds_not_in: [BigInt!]
  upperTarget: BigDecimal
  upperTarget_gt: BigDecimal
  upperTarget_gte: BigDecimal
  upperTarget_in: [BigDecimal!]
  upperTarget_lt: BigDecimal
  upperTarget_lte: BigDecimal
  upperTarget_not: BigDecimal
  upperTarget_not_in: [BigDecimal!]
  v: BigDecimal
  v_gt: BigDecimal
  v_gte: BigDecimal
  v_in: [BigDecimal!]
  v_lt: BigDecimal
  v_lte: BigDecimal
  v_not: BigDecimal
  v_not_in: [BigDecimal!]
  vaultID: String
  vaultID_: Balancer_filter
  vaultID_contains: String
  vaultID_contains_nocase: String
  vaultID_ends_with: String
  vaultID_ends_with_nocase: String
  vaultID_gt: String
  vaultID_gte: String
  vaultID_in: [String!]
  vaultID_lt: String
  vaultID_lte: String
  vaultID_not: String
  vaultID_not_contains: String
  vaultID_not_contains_nocase: String
  vaultID_not_ends_with: String
  vaultID_not_ends_with_nocase: String
  vaultID_not_in: [String!]
  vaultID_not_starts_with: String
  vaultID_not_starts_with_nocase: String
  vaultID_starts_with: String
  vaultID_starts_with_nocase: String
  w: BigDecimal
  w_gt: BigDecimal
  w_gte: BigDecimal
  w_in: [BigDecimal!]
  w_lt: BigDecimal
  w_lte: BigDecimal
  w_not: BigDecimal
  w_not_in: [BigDecimal!]
  weightUpdates_: GradualWeightUpdate_filter
  wrappedIndex: Int
  wrappedIndex_gt: Int
  wrappedIndex_gte: Int
  wrappedIndex_in: [Int!]
  wrappedIndex_lt: Int
  wrappedIndex_lte: Int
  wrappedIndex_not: Int
  wrappedIndex_not_in: [Int!]
  z: BigDecimal
  z_gt: BigDecimal
  z_gte: BigDecimal
  z_in: [BigDecimal!]
  z_lt: BigDecimal
  z_lte: BigDecimal
  z_not: BigDecimal
  z_not_in: [BigDecimal!]
}

enum Pool_orderBy {
  address
  alpha
  amp
  ampUpdates
  baseToken
  beta
  c
  circuitBreakers
  createTime
  dSq
  delta
  epsilon
  expiryTime
  factory
  gauges
  gaugesList
  historicalValues
  holdersCount
  id
  isInRecoveryMode
  isPaused
  joinExitEnabled
  joinsExits
  lambda
  lastJoinExitAmp
  lastPostJoinExitInvariant
  latestAmpUpdate
  latestAmpUpdate__endAmp
  latestAmpUpdate__endTimestamp
  latestAmpUpdate__id
  latestAmpUpdate__scheduledTimestamp
  latestAmpUpdate__startAmp
  latestAmpUpdate__startTimestamp
  lowerTarget
  mainIndex
  managementAumFee
  managementFee
  mustAllowlistLPs
  name
  oracleEnabled
  owner
  poolId
  poolType
  poolTypeVersion
  preferentialGauge
  preferentialGauge__id
  preferentialGauge__isKilled
  preferentialGauge__isPreferentialGauge
  preferentialGauge__poolAddress
  preferentialGauge__poolId
  preferentialGauge__relativeWeightCap
  preferentialGauge__streamer
  preferentialGauge__symbol
  preferentialGauge__totalSupply
  priceRateProviders
  principalToken
  protocolAumFeeCache
  protocolId
  protocolIdData
  protocolIdData__id
  protocolIdData__name
  protocolSwapFeeCache
  protocolYieldFeeCache
  root3Alpha
  s
  shares
  snapshots
  sqrtAlpha
  sqrtBeta
  strategyType
  swapEnabled
  swapEnabledCurationSignal
  swapEnabledInternal
  swapFee
  swaps
  swapsCount
  symbol
  tauAlphaX
  tauAlphaY
  tauBetaX
  tauBetaY
  tokens
  tokensList
  totalAumFeeCollectedInBPT
  totalLiquidity
  totalLiquiditySansBPT
  totalProtocolFee
  totalProtocolFeePaidInBPT
  totalShares
  totalSwapFee
  totalSwapVolume
  totalWeight
  tx
  u
  unitSeconds
  upperTarget
  v
  vaultID
  vaultID__id
  vaultID__poolCount
  vaultID__protocolFeesCollector
  vaultID__totalLiquidity
  vaultID__totalProtocolFee
  vaultID__totalSwapCount
  vaultID__totalSwapFee
  vaultID__totalSwapVolume
  w
  weightUpdates
  wrappedIndex
  z
}

type PriceRateProvider {
  address: Bytes!
  cacheDuration: Int
  cacheExpiry: Int
  id: ID!
  lastCached: Int
  poolId: Pool!
  rate: BigDecimal
  token: PoolToken!
}

input PriceRateProvider_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  address: Bytes
  address_contains: Bytes
  address_gt: Bytes
  address_gte: Bytes
  address_in: [Bytes!]
  address_lt: Bytes
  address_lte: Bytes
  address_not: Bytes
  address_not_contains: Bytes
  address_not_in: [Bytes!]
  and: [PriceRateProvider_filter]
  cacheDuration: Int
  cacheDuration_gt: Int
  cacheDuration_gte: Int
  cacheDuration_in: [Int!]
  cacheDuration_lt: Int
  cacheDuration_lte: Int
  cacheDuration_not: Int
  cacheDuration_not_in: [Int!]
  cacheExpiry: Int
  cacheExpiry_gt: Int
  cacheExpiry_gte: Int
  cacheExpiry_in: [Int!]
  cacheExpiry_lt: Int
  cacheExpiry_lte: Int
  cacheExpiry_not: Int
  cacheExpiry_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lastCached: Int
  lastCached_gt: Int
  lastCached_gte: Int
  lastCached_in: [Int!]
  lastCached_lt: Int
  lastCached_lte: Int
  lastCached_not: Int
  lastCached_not_in: [Int!]
  or: [PriceRateProvider_filter]
  poolId: String
  poolId_: Pool_filter
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  rate: BigDecimal
  rate_gt: BigDecimal
  rate_gte: BigDecimal
  rate_in: [BigDecimal!]
  rate_lt: BigDecimal
  rate_lte: BigDecimal
  rate_not: BigDecimal
  rate_not_in: [BigDecimal!]
  token: String
  token_: PoolToken_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
}

enum PriceRateProvider_orderBy {
  address
  cacheDuration
  cacheExpiry
  id
  lastCached
  poolId
  poolId__address
  poolId__alpha
  poolId__amp
  poolId__baseToken
  poolId__beta
  poolId__c
  poolId__createTime
  poolId__dSq
  poolId__delta
  poolId__epsilon
  poolId__expiryTime
  poolId__factory
  poolId__holdersCount
  poolId__id
  poolId__isInRecoveryMode
  poolId__isPaused
  poolId__joinExitEnabled
  poolId__lambda
  poolId__lastJoinExitAmp
  poolId__lastPostJoinExitInvariant
  poolId__lowerTarget
  poolId__mainIndex
  poolId__managementAumFee
  poolId__managementFee
  poolId__mustAllowlistLPs
  poolId__name
  poolId__oracleEnabled
  poolId__owner
  poolId__poolType
  poolId__poolTypeVersion
  poolId__principalToken
  poolId__protocolAumFeeCache
  poolId__protocolId
  poolId__protocolSwapFeeCache
  poolId__protocolYieldFeeCache
  poolId__root3Alpha
  poolId__s
  poolId__sqrtAlpha
  poolId__sqrtBeta
  poolId__strategyType
  poolId__swapEnabled
  poolId__swapEnabledCurationSignal
  poolId__swapEnabledInternal
  poolId__swapFee
  poolId__swapsCount
  poolId__symbol
  poolId__tauAlphaX
  poolId__tauAlphaY
  poolId__tauBetaX
  poolId__tauBetaY
  poolId__totalAumFeeCollectedInBPT
  poolId__totalLiquidity
  poolId__totalLiquiditySansBPT
  poolId__totalProtocolFee
  poolId__totalProtocolFeePaidInBPT
  poolId__totalShares
  poolId__totalSwapFee
  poolId__totalSwapVolume
  poolId__totalWeight
  poolId__tx
  poolId__u
  poolId__unitSeconds
  poolId__upperTarget
  poolId__v
  poolId__w
  poolId__wrappedIndex
  poolId__z
  rate
  token
  token__address
  token__assetManager
  token__balance
  token__cashBalance
  token__decimals
  token__id
  token__index
  token__isExemptFromYieldProtocolFee
  token__managedBalance
  token__name
  token__oldPriceRate
  token__paidProtocolFees
  token__priceRate
  token__symbol
  token__weight
}

type ProtocolIdData {
  id: ID!
  name: String!
}

input ProtocolIdData_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [ProtocolIdData_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  name: String
  name_contains: String
  name_contains_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  or: [ProtocolIdData_filter]
}

enum ProtocolIdData_orderBy {
  id
  name
}

type QuantAMMWeightedDetail {
  category: String!
  name: String!
  type: String!
  value: String!
}

type QuantAmmWeightSnapshot {
  timestamp: Int!
  weights: [Float!]
}

type QuantAmmWeightedParams {
  absoluteWeightGuardRail: String!
  details: [QuantAMMWeightedDetail!]!
  epsilonMax: String!
  lambda: [String!]!
  lastInterpolationTimePossible: String!
  lastUpdateIntervalTime: String!
  maxTradeSizeRatio: String!
  oracleStalenessThreshold: String!
  poolRegistry: String!
  updateInterval: String!
  weightBlockMultipliers: [String!]!
  weightsAtLastUpdateInterval: [String!]!
}

type Query {
  """
  Access to subgraph metadata
  """
  _meta(block: Block_height): _Meta_

  """
  Returns all pools for a given filter, specific for aggregators
  """
  aggregatorPools(
    first: Int
    orderBy: GqlPoolOrderBy
    orderDirection: GqlPoolOrderDirection
    skip: Int
    where: GqlAggregatorPoolFilter
  ): [GqlPoolAggregator!]!
  ampUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AmpUpdate
  ampUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: AmpUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: AmpUpdate_filter
  ): [AmpUpdate!]!
  balancer(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Balancer
  balancerSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BalancerSnapshot
  balancerSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: BalancerSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: BalancerSnapshot_filter
  ): [BalancerSnapshot!]!
  balancers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Balancer_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Balancer_filter
  ): [Balancer!]!
  beetsPoolGetReliquaryFarmSnapshots(
    chain: GqlChain!
    id: String!
    range: GqlPoolSnapshotDataRange!
  ): [GqlReliquaryFarmSnapshot!]!
  block(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Block
  blocks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Block_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Block_filter
  ): [Block!]!
  circuitBreaker(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CircuitBreaker
  circuitBreakers(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: CircuitBreaker_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: CircuitBreaker_filter
  ): [CircuitBreaker!]!
  fxoracle(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FXOracle
  fxoracles(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: FXOracle_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: FXOracle_filter
  ): [FXOracle!]!
  gauge(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Gauge
  gaugeFactories(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: GaugeFactory_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: GaugeFactory_filter
  ): [GaugeFactory!]!
  gaugeFactory(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GaugeFactory
  gaugeInjector(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GaugeInjector
  gaugeInjectors(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: GaugeInjector_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: GaugeInjector_filter
  ): [GaugeInjector!]!
  gaugeShare(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GaugeShare
  gaugeShares(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: GaugeShare_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: GaugeShare_filter
  ): [GaugeShare!]!
  gaugeType(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GaugeType
  gaugeTypes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: GaugeType_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: GaugeType_filter
  ): [GaugeType!]!
  gaugeVote(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GaugeVote
  gaugeVotes(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: GaugeVote_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: GaugeVote_filter
  ): [GaugeVote!]!
  gauges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Gauge_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Gauge_filter
  ): [Gauge!]!
  gradualWeightUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GradualWeightUpdate
  gradualWeightUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: GradualWeightUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: GradualWeightUpdate_filter
  ): [GradualWeightUpdate!]!
  joinExit(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): JoinExit
  joinExits(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: JoinExit_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: JoinExit_filter
  ): [JoinExit!]!
  latestPrice(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LatestPrice
  latestPrices(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LatestPrice_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LatestPrice_filter
  ): [LatestPrice!]!
  lbpPriceChart(
    chain: GqlChain!
    dataPoints: Int
    id: String!
  ): [LBPPriceChartData!]
  liquidityGauge(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LiquidityGauge
  liquidityGauges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LiquidityGauge_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LiquidityGauge_filter
  ): [LiquidityGauge!]!
  lockSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LockSnapshot
  lockSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: LockSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: LockSnapshot_filter
  ): [LockSnapshot!]!

  """
  Get the LoopS data
  """
  loopsGetData: GqlLoopsData!
  managementOperation(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ManagementOperation
  managementOperations(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ManagementOperation_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ManagementOperation_filter
  ): [ManagementOperation!]!
  omniVotingEscrowLock(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OmniVotingEscrowLock
  omniVotingEscrowLocks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: OmniVotingEscrowLock_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: OmniVotingEscrowLock_filter
  ): [OmniVotingEscrowLock!]!
  pool(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Pool
  poolContract(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolContract
  poolContracts(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolContract_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolContract_filter
  ): [PoolContract!]!

  """
  Getting swap, add and remove events with paging
  """
  poolEvents(
    first: Int
    skip: Int
    where: GqlPoolEventsFilter
  ): [GqlPoolEvent!]!

  """
  Returns all pools for a given filter, specific for aggregators
  """
  poolGetAggregatorPools(
    first: Int
    orderBy: GqlPoolOrderBy
    orderDirection: GqlPoolOrderDirection
    skip: Int
    where: GqlPoolFilter
  ): [GqlPoolAggregator!]! @deprecated(reason: "Use aggregatorPools instead")

  """
  Returns the list of featured pools for chains
  """
  poolGetFeaturedPools(chains: [GqlChain!]!): [GqlPoolFeaturedPool!]!

  """
  Returns one pool. If a user address is provided, the user balances for the given pool will also be returned.
  """
  poolGetPool(chain: GqlChain!, id: String!, userAddress: String): GqlPoolBase!

  """
  Returns all pools for a given filter
  """
  poolGetPools(
    first: Int
    orderBy: GqlPoolOrderBy
    orderDirection: GqlPoolOrderDirection
    skip: Int
    textSearch: String
    where: GqlPoolFilter
  ): [GqlPoolMinimal!]!

  """
  Returns the number of pools for a given filter.
  """
  poolGetPoolsCount(
    first: Int
    orderBy: GqlPoolOrderBy
    orderDirection: GqlPoolOrderDirection
    skip: Int
    textSearch: String
    where: GqlPoolFilter
  ): Int!

  """
  Gets all the snapshots for a given pool on a chain for a certain range
  """
  poolGetSnapshots(
    chain: GqlChain!
    id: String!
    range: GqlPoolSnapshotDataRange!
  ): [GqlPoolSnapshot!]!
  poolHistoricalLiquidities(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolHistoricalLiquidity_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolHistoricalLiquidity_filter
  ): [PoolHistoricalLiquidity!]!
  poolHistoricalLiquidity(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolHistoricalLiquidity
  poolShare(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolShare
  poolShares(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolShare_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolShare_filter
  ): [PoolShare!]!
  poolSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolSnapshot
  poolSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolSnapshot_filter
  ): [PoolSnapshot!]!
  poolToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PoolToken
  poolTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PoolToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PoolToken_filter
  ): [PoolToken!]!
  pools(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Pool_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Pool_filter
  ): [Pool!]!
  priceRateProvider(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PriceRateProvider
  priceRateProviders(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: PriceRateProvider_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: PriceRateProvider_filter
  ): [PriceRateProvider!]!
  protocolIdData(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ProtocolIdData
  protocolIdDatas(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: ProtocolIdData_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: ProtocolIdData_filter
  ): [ProtocolIdData!]!
  protocolMetricsAggregated(chains: [GqlChain!]!): GqlProtocolMetricsAggregated!
  protocolMetricsChain(chain: GqlChain!): GqlProtocolMetricsChain!
  rewardToken(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardToken
  rewardTokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RewardToken_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RewardToken_filter
  ): [RewardToken!]!
  rootGauge(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RootGauge
  rootGauges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: RootGauge_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: RootGauge_filter
  ): [RootGauge!]!
  singleRecipientGauge(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SingleRecipientGauge
  singleRecipientGauges(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SingleRecipientGauge_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SingleRecipientGauge_filter
  ): [SingleRecipientGauge!]!

  """
  Get swap quote from the SOR v2
  """
  sorGetSwapPaths(
    """
    The Chain to query
    """
    chain: GqlChain!

    """
    Whether it should consider pools that have hooks. Default is false if not provided.
    """
    considerPoolsWithHooks: Boolean

    """
    Use specified poolIds only
    """
    poolIds: [String!]

    """
    The amount to swap, in human form.
    """
    swapAmount: AmountHumanReadable!

    """
    SwapType either exact_in or exact_out (also givenIn or givenOut)
    """
    swapType: GqlSorSwapType!

    """
    Token address of the tokenIn
    """
    tokenIn: String!

    """
    Token address of the tokenOut
    """
    tokenOut: String!

    """
    Which protocol version to use (currently 2 and 3). If none provided, will chose the better return from any version
    """
    useProtocolVersion: Int
  ): GqlSorGetSwapPaths!

  """
  Get the staking data and status for stS
  """
  stsGetGqlStakedSonicData: GqlStakedSonicData!

  """
  Get snapshots for sftmx staking for a specific range
  """
  stsGetStakedSonicSnapshots(
    range: GqlStakedSonicSnapshotDataRange!
  ): [GqlStakedSonicSnapshot!]!
  swap(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Swap
  swapFeeUpdate(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SwapFeeUpdate
  swapFeeUpdates(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: SwapFeeUpdate_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: SwapFeeUpdate_filter
  ): [SwapFeeUpdate!]!
  swaps(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Swap_filter
  ): [Swap!]!
  token(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token

  """
  Returns all current prices for allowed tokens for a given chain or chains
  """
  tokenGetCurrentPrices(chains: [GqlChain!]!): [GqlTokenPrice!]!

  """
  Returns the historical prices for a given set of tokens for a given chain and range
  """
  tokenGetHistoricalPrices(
    addresses: [String!]!
    chain: GqlChain!
    range: GqlTokenChartDataRange!
  ): [GqlHistoricalTokenPrice!]!

  """
  Returns the price of a token priced in another token for a given range.
  """
  tokenGetRelativePriceChartData(
    chain: GqlChain!
    range: GqlTokenChartDataRange!
    tokenIn: String!
    tokenOut: String!
  ): [GqlTokenPriceChartDataItem!]!

  """
  Returns dynamic data of a token such as price, market cap, etc.
  """
  tokenGetTokenDynamicData(
    address: String!
    chain: GqlChain!
  ): GqlTokenDynamicData

  """
  Returns all allowed tokens for a given chain or chains
  """
  tokenGetTokens(chains: [GqlChain!]!, where: GqlTokenFilter): [GqlToken!]!

  """
  Returns dynamic data of a set of tokens such as price, market cap, etc.
  """
  tokenGetTokensDynamicData(
    addresses: [String!]!
    chain: GqlChain!
  ): [GqlTokenDynamicData!]!
  tokenPrice(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenPrice
  tokenPrices(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenPrice_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenPrice_filter
  ): [TokenPrice!]!
  tokenSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenSnapshot
  tokenSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TokenSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TokenSnapshot_filter
  ): [TokenSnapshot!]!
  tokens(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: Token_filter
  ): [Token!]!
  tradePair(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TradePair
  tradePairSnapshot(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TradePairSnapshot
  tradePairSnapshots(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TradePairSnapshot_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TradePairSnapshot_filter
  ): [TradePairSnapshot!]!
  tradePairs(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: TradePair_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: TradePair_filter
  ): [TradePair!]!
  user(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  userInternalBalance(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserInternalBalance
  userInternalBalances(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: UserInternalBalance_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: UserInternalBalance_filter
  ): [UserInternalBalance!]!
  users(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: User_filter
  ): [User!]!
  veBalGetTotalSupply(chain: GqlChain!): AmountHumanReadable!
  veBalGetUser(address: String!, chain: GqlChain!): GqlVeBalUserData!
  veBalGetUserBalance(address: String!, chain: GqlChain!): AmountHumanReadable!
  veBalGetUserBalances(
    address: String!
    chains: [GqlChain!]!
  ): [GqlVeBalBalance!]!

  """
  Returns all pools with veBAL gauges that can be voted on.
  """
  veBalGetVotingList(includeKilled: Boolean): [GqlVotingPool!]!
  votingEscrow(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VotingEscrow
  votingEscrowLock(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    id: ID!

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): VotingEscrowLock
  votingEscrowLocks(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VotingEscrowLock_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VotingEscrowLock_filter
  ): [VotingEscrowLock!]!
  votingEscrows(
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    first: Int = 100
    orderBy: VotingEscrow_orderBy
    orderDirection: OrderDirection
    skip: Int = 0

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
    where: VotingEscrow_filter
  ): [VotingEscrow!]!
}

type RewardToken {
  """
  ERC20 token decimals - zero if call to decimals() reverts
  """
  decimals: Int!

  """
  Reference to LiquidityGauge entity
  """
  gauge: LiquidityGauge!

  """
  Equal to: <tokenAddress>-<gaugeAddress>
  """
  id: ID!

  """
  Timestamp at which finishes the period of rewards
  """
  periodFinish: BigInt

  """
  Rate of reward tokens streamed per second
  """
  rate: BigDecimal

  """
  ERC20 token symbol - empty string if call to symbol() reverts
  """
  symbol: String!

  """
  Amount of reward tokens that has been deposited into the gauge
  """
  totalDeposited: BigDecimal!
}

input RewardToken_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [RewardToken_filter]
  decimals: Int
  decimals_gt: Int
  decimals_gte: Int
  decimals_in: [Int!]
  decimals_lt: Int
  decimals_lte: Int
  decimals_not: Int
  decimals_not_in: [Int!]
  gauge: String
  gauge_: LiquidityGauge_filter
  gauge_contains: String
  gauge_contains_nocase: String
  gauge_ends_with: String
  gauge_ends_with_nocase: String
  gauge_gt: String
  gauge_gte: String
  gauge_in: [String!]
  gauge_lt: String
  gauge_lte: String
  gauge_not: String
  gauge_not_contains: String
  gauge_not_contains_nocase: String
  gauge_not_ends_with: String
  gauge_not_ends_with_nocase: String
  gauge_not_in: [String!]
  gauge_not_starts_with: String
  gauge_not_starts_with_nocase: String
  gauge_starts_with: String
  gauge_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [RewardToken_filter]
  periodFinish: BigInt
  periodFinish_gt: BigInt
  periodFinish_gte: BigInt
  periodFinish_in: [BigInt!]
  periodFinish_lt: BigInt
  periodFinish_lte: BigInt
  periodFinish_not: BigInt
  periodFinish_not_in: [BigInt!]
  rate: BigDecimal
  rate_gt: BigDecimal
  rate_gte: BigDecimal
  rate_in: [BigDecimal!]
  rate_lt: BigDecimal
  rate_lte: BigDecimal
  rate_not: BigDecimal
  rate_not_in: [BigDecimal!]
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  totalDeposited: BigDecimal
  totalDeposited_gt: BigDecimal
  totalDeposited_gte: BigDecimal
  totalDeposited_in: [BigDecimal!]
  totalDeposited_lt: BigDecimal
  totalDeposited_lte: BigDecimal
  totalDeposited_not: BigDecimal
  totalDeposited_not_in: [BigDecimal!]
}

enum RewardToken_orderBy {
  decimals
  gauge
  gauge__id
  gauge__isKilled
  gauge__isPreferentialGauge
  gauge__poolAddress
  gauge__poolId
  gauge__relativeWeightCap
  gauge__streamer
  gauge__symbol
  gauge__totalSupply
  id
  periodFinish
  rate
  symbol
  totalDeposited
}

type RootGauge {
  """
  Chain where emissions by this gauge will be bridged to
  """
  chain: Chain!

  """
  Factory contract address
  """
  factory: GaugeFactory!

  """
  Reference to Gauge entity - created when LiquidityGauge is added to GaugeController
  """
  gauge: Gauge

  """
  RootGauge contract address
  """
  id: ID!

  """
  Whether Balancer DAO killed the gauge
  """
  isKilled: Boolean!

  """
  Address where emissions by this gauge will be bridged to
  """
  recipient: Bytes!

  """
  Relative weight cap of the gauge (0.01 = 1%) - V2 factories only
  """
  relativeWeightCap: BigDecimal
}

input RootGauge_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [RootGauge_filter]
  chain: Chain
  chain_in: [Chain!]
  chain_not: Chain
  chain_not_in: [Chain!]
  factory: String
  factory_: GaugeFactory_filter
  factory_contains: String
  factory_contains_nocase: String
  factory_ends_with: String
  factory_ends_with_nocase: String
  factory_gt: String
  factory_gte: String
  factory_in: [String!]
  factory_lt: String
  factory_lte: String
  factory_not: String
  factory_not_contains: String
  factory_not_contains_nocase: String
  factory_not_ends_with: String
  factory_not_ends_with_nocase: String
  factory_not_in: [String!]
  factory_not_starts_with: String
  factory_not_starts_with_nocase: String
  factory_starts_with: String
  factory_starts_with_nocase: String
  gauge: String
  gauge_: Gauge_filter
  gauge_contains: String
  gauge_contains_nocase: String
  gauge_ends_with: String
  gauge_ends_with_nocase: String
  gauge_gt: String
  gauge_gte: String
  gauge_in: [String!]
  gauge_lt: String
  gauge_lte: String
  gauge_not: String
  gauge_not_contains: String
  gauge_not_contains_nocase: String
  gauge_not_ends_with: String
  gauge_not_ends_with_nocase: String
  gauge_not_in: [String!]
  gauge_not_starts_with: String
  gauge_not_starts_with_nocase: String
  gauge_starts_with: String
  gauge_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isKilled: Boolean
  isKilled_in: [Boolean!]
  isKilled_not: Boolean
  isKilled_not_in: [Boolean!]
  or: [RootGauge_filter]
  recipient: Bytes
  recipient_contains: Bytes
  recipient_gt: Bytes
  recipient_gte: Bytes
  recipient_in: [Bytes!]
  recipient_lt: Bytes
  recipient_lte: Bytes
  recipient_not: Bytes
  recipient_not_contains: Bytes
  recipient_not_in: [Bytes!]
  relativeWeightCap: BigDecimal
  relativeWeightCap_gt: BigDecimal
  relativeWeightCap_gte: BigDecimal
  relativeWeightCap_in: [BigDecimal!]
  relativeWeightCap_lt: BigDecimal
  relativeWeightCap_lte: BigDecimal
  relativeWeightCap_not: BigDecimal
  relativeWeightCap_not_in: [BigDecimal!]
}

enum RootGauge_orderBy {
  chain
  factory
  factory__id
  factory__numGauges
  gauge
  gauge__addedTimestamp
  gauge__address
  gauge__id
  id
  isKilled
  recipient
  relativeWeightCap
}

type SingleRecipientGauge {
  """
  Factory contract address
  """
  factory: GaugeFactory!

  """
  Reference to Gauge entity - created when SingleRecipientGauge is added to GaugeController
  """
  gauge: Gauge

  """
  SingleRecipientGauge contract address
  """
  id: ID!

  """
  Whether Balancer DAO killed the gauge
  """
  isKilled: Boolean!

  """
  Address where emissions for this gauge will be sent to
  """
  recipient: Bytes!

  """
  Relative weight cap of the gauge (0.01 = 1%) - V2 factories only
  """
  relativeWeightCap: BigDecimal
}

input SingleRecipientGauge_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [SingleRecipientGauge_filter]
  factory: String
  factory_: GaugeFactory_filter
  factory_contains: String
  factory_contains_nocase: String
  factory_ends_with: String
  factory_ends_with_nocase: String
  factory_gt: String
  factory_gte: String
  factory_in: [String!]
  factory_lt: String
  factory_lte: String
  factory_not: String
  factory_not_contains: String
  factory_not_contains_nocase: String
  factory_not_ends_with: String
  factory_not_ends_with_nocase: String
  factory_not_in: [String!]
  factory_not_starts_with: String
  factory_not_starts_with_nocase: String
  factory_starts_with: String
  factory_starts_with_nocase: String
  gauge: String
  gauge_: Gauge_filter
  gauge_contains: String
  gauge_contains_nocase: String
  gauge_ends_with: String
  gauge_ends_with_nocase: String
  gauge_gt: String
  gauge_gte: String
  gauge_in: [String!]
  gauge_lt: String
  gauge_lte: String
  gauge_not: String
  gauge_not_contains: String
  gauge_not_contains_nocase: String
  gauge_not_ends_with: String
  gauge_not_ends_with_nocase: String
  gauge_not_in: [String!]
  gauge_not_starts_with: String
  gauge_not_starts_with_nocase: String
  gauge_starts_with: String
  gauge_starts_with_nocase: String
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  isKilled: Boolean
  isKilled_in: [Boolean!]
  isKilled_not: Boolean
  isKilled_not_in: [Boolean!]
  or: [SingleRecipientGauge_filter]
  recipient: Bytes
  recipient_contains: Bytes
  recipient_gt: Bytes
  recipient_gte: Bytes
  recipient_in: [Bytes!]
  recipient_lt: Bytes
  recipient_lte: Bytes
  recipient_not: Bytes
  recipient_not_contains: Bytes
  recipient_not_in: [Bytes!]
  relativeWeightCap: BigDecimal
  relativeWeightCap_gt: BigDecimal
  relativeWeightCap_gte: BigDecimal
  relativeWeightCap_in: [BigDecimal!]
  relativeWeightCap_lt: BigDecimal
  relativeWeightCap_lte: BigDecimal
  relativeWeightCap_not: BigDecimal
  relativeWeightCap_not_in: [BigDecimal!]
}

enum SingleRecipientGauge_orderBy {
  factory
  factory__id
  factory__numGauges
  gauge
  gauge__addedTimestamp
  gauge__address
  gauge__id
  id
  isKilled
  recipient
  relativeWeightCap
}

"""
StableSurge hook specific params. Percentage format is 0.01 -> 0.01%.
"""
type StableSurgeHookParams {
  maxSurgeFeePercentage: String
  surgeThresholdPercentage: String
}

type Swap {
  block: BigInt
  caller: Bytes!
  id: ID!
  poolId: Pool!
  timestamp: Int!
  tokenAmountIn: BigDecimal!
  tokenAmountOut: BigDecimal!
  tokenIn: Bytes!
  tokenInSym: String!
  tokenOut: Bytes!
  tokenOutSym: String!
  tx: Bytes!
  userAddress: User!
  valueUSD: BigDecimal!
}

type SwapFeeUpdate {
  endSwapFeePercentage: BigDecimal!
  endTimestamp: BigInt!
  id: ID!
  pool: Pool!
  scheduledTimestamp: Int!
  startSwapFeePercentage: BigDecimal!
  startTimestamp: BigInt!
}

input SwapFeeUpdate_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [SwapFeeUpdate_filter]
  endSwapFeePercentage: BigDecimal
  endSwapFeePercentage_gt: BigDecimal
  endSwapFeePercentage_gte: BigDecimal
  endSwapFeePercentage_in: [BigDecimal!]
  endSwapFeePercentage_lt: BigDecimal
  endSwapFeePercentage_lte: BigDecimal
  endSwapFeePercentage_not: BigDecimal
  endSwapFeePercentage_not_in: [BigDecimal!]
  endTimestamp: BigInt
  endTimestamp_gt: BigInt
  endTimestamp_gte: BigInt
  endTimestamp_in: [BigInt!]
  endTimestamp_lt: BigInt
  endTimestamp_lte: BigInt
  endTimestamp_not: BigInt
  endTimestamp_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [SwapFeeUpdate_filter]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  scheduledTimestamp: Int
  scheduledTimestamp_gt: Int
  scheduledTimestamp_gte: Int
  scheduledTimestamp_in: [Int!]
  scheduledTimestamp_lt: Int
  scheduledTimestamp_lte: Int
  scheduledTimestamp_not: Int
  scheduledTimestamp_not_in: [Int!]
  startSwapFeePercentage: BigDecimal
  startSwapFeePercentage_gt: BigDecimal
  startSwapFeePercentage_gte: BigDecimal
  startSwapFeePercentage_in: [BigDecimal!]
  startSwapFeePercentage_lt: BigDecimal
  startSwapFeePercentage_lte: BigDecimal
  startSwapFeePercentage_not: BigDecimal
  startSwapFeePercentage_not_in: [BigDecimal!]
  startTimestamp: BigInt
  startTimestamp_gt: BigInt
  startTimestamp_gte: BigInt
  startTimestamp_in: [BigInt!]
  startTimestamp_lt: BigInt
  startTimestamp_lte: BigInt
  startTimestamp_not: BigInt
  startTimestamp_not_in: [BigInt!]
}

enum SwapFeeUpdate_orderBy {
  endSwapFeePercentage
  endTimestamp
  id
  pool
  pool__address
  pool__alpha
  pool__amp
  pool__baseToken
  pool__beta
  pool__c
  pool__createTime
  pool__dSq
  pool__delta
  pool__epsilon
  pool__expiryTime
  pool__factory
  pool__holdersCount
  pool__id
  pool__isInRecoveryMode
  pool__isPaused
  pool__joinExitEnabled
  pool__lambda
  pool__lastJoinExitAmp
  pool__lastPostJoinExitInvariant
  pool__lowerTarget
  pool__mainIndex
  pool__managementAumFee
  pool__managementFee
  pool__mustAllowlistLPs
  pool__name
  pool__oracleEnabled
  pool__owner
  pool__poolType
  pool__poolTypeVersion
  pool__principalToken
  pool__protocolAumFeeCache
  pool__protocolId
  pool__protocolSwapFeeCache
  pool__protocolYieldFeeCache
  pool__root3Alpha
  pool__s
  pool__sqrtAlpha
  pool__sqrtBeta
  pool__strategyType
  pool__swapEnabled
  pool__swapEnabledCurationSignal
  pool__swapEnabledInternal
  pool__swapFee
  pool__swapsCount
  pool__symbol
  pool__tauAlphaX
  pool__tauAlphaY
  pool__tauBetaX
  pool__tauBetaY
  pool__totalAumFeeCollectedInBPT
  pool__totalLiquidity
  pool__totalLiquiditySansBPT
  pool__totalProtocolFee
  pool__totalProtocolFeePaidInBPT
  pool__totalShares
  pool__totalSwapFee
  pool__totalSwapVolume
  pool__totalWeight
  pool__tx
  pool__u
  pool__unitSeconds
  pool__upperTarget
  pool__v
  pool__w
  pool__wrappedIndex
  pool__z
  scheduledTimestamp
  startSwapFeePercentage
  startTimestamp
}

input Swap_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [Swap_filter]
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  caller: Bytes
  caller_contains: Bytes
  caller_gt: Bytes
  caller_gte: Bytes
  caller_in: [Bytes!]
  caller_lt: Bytes
  caller_lte: Bytes
  caller_not: Bytes
  caller_not_contains: Bytes
  caller_not_in: [Bytes!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [Swap_filter]
  poolId: String
  poolId_: Pool_filter
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  tokenAmountIn: BigDecimal
  tokenAmountIn_gt: BigDecimal
  tokenAmountIn_gte: BigDecimal
  tokenAmountIn_in: [BigDecimal!]
  tokenAmountIn_lt: BigDecimal
  tokenAmountIn_lte: BigDecimal
  tokenAmountIn_not: BigDecimal
  tokenAmountIn_not_in: [BigDecimal!]
  tokenAmountOut: BigDecimal
  tokenAmountOut_gt: BigDecimal
  tokenAmountOut_gte: BigDecimal
  tokenAmountOut_in: [BigDecimal!]
  tokenAmountOut_lt: BigDecimal
  tokenAmountOut_lte: BigDecimal
  tokenAmountOut_not: BigDecimal
  tokenAmountOut_not_in: [BigDecimal!]
  tokenIn: Bytes
  tokenInSym: String
  tokenInSym_contains: String
  tokenInSym_contains_nocase: String
  tokenInSym_ends_with: String
  tokenInSym_ends_with_nocase: String
  tokenInSym_gt: String
  tokenInSym_gte: String
  tokenInSym_in: [String!]
  tokenInSym_lt: String
  tokenInSym_lte: String
  tokenInSym_not: String
  tokenInSym_not_contains: String
  tokenInSym_not_contains_nocase: String
  tokenInSym_not_ends_with: String
  tokenInSym_not_ends_with_nocase: String
  tokenInSym_not_in: [String!]
  tokenInSym_not_starts_with: String
  tokenInSym_not_starts_with_nocase: String
  tokenInSym_starts_with: String
  tokenInSym_starts_with_nocase: String
  tokenIn_contains: Bytes
  tokenIn_gt: Bytes
  tokenIn_gte: Bytes
  tokenIn_in: [Bytes!]
  tokenIn_lt: Bytes
  tokenIn_lte: Bytes
  tokenIn_not: Bytes
  tokenIn_not_contains: Bytes
  tokenIn_not_in: [Bytes!]
  tokenOut: Bytes
  tokenOutSym: String
  tokenOutSym_contains: String
  tokenOutSym_contains_nocase: String
  tokenOutSym_ends_with: String
  tokenOutSym_ends_with_nocase: String
  tokenOutSym_gt: String
  tokenOutSym_gte: String
  tokenOutSym_in: [String!]
  tokenOutSym_lt: String
  tokenOutSym_lte: String
  tokenOutSym_not: String
  tokenOutSym_not_contains: String
  tokenOutSym_not_contains_nocase: String
  tokenOutSym_not_ends_with: String
  tokenOutSym_not_ends_with_nocase: String
  tokenOutSym_not_in: [String!]
  tokenOutSym_not_starts_with: String
  tokenOutSym_not_starts_with_nocase: String
  tokenOutSym_starts_with: String
  tokenOutSym_starts_with_nocase: String
  tokenOut_contains: Bytes
  tokenOut_gt: Bytes
  tokenOut_gte: Bytes
  tokenOut_in: [Bytes!]
  tokenOut_lt: Bytes
  tokenOut_lte: Bytes
  tokenOut_not: Bytes
  tokenOut_not_contains: Bytes
  tokenOut_not_in: [Bytes!]
  tx: Bytes
  tx_contains: Bytes
  tx_gt: Bytes
  tx_gte: Bytes
  tx_in: [Bytes!]
  tx_lt: Bytes
  tx_lte: Bytes
  tx_not: Bytes
  tx_not_contains: Bytes
  tx_not_in: [Bytes!]
  userAddress: String
  userAddress_: User_filter
  userAddress_contains: String
  userAddress_contains_nocase: String
  userAddress_ends_with: String
  userAddress_ends_with_nocase: String
  userAddress_gt: String
  userAddress_gte: String
  userAddress_in: [String!]
  userAddress_lt: String
  userAddress_lte: String
  userAddress_not: String
  userAddress_not_contains: String
  userAddress_not_contains_nocase: String
  userAddress_not_ends_with: String
  userAddress_not_ends_with_nocase: String
  userAddress_not_in: [String!]
  userAddress_not_starts_with: String
  userAddress_not_starts_with_nocase: String
  userAddress_starts_with: String
  userAddress_starts_with_nocase: String
  valueUSD: BigDecimal
  valueUSD_gt: BigDecimal
  valueUSD_gte: BigDecimal
  valueUSD_in: [BigDecimal!]
  valueUSD_lt: BigDecimal
  valueUSD_lte: BigDecimal
  valueUSD_not: BigDecimal
  valueUSD_not_in: [BigDecimal!]
}

enum Swap_orderBy {
  block
  caller
  id
  poolId
  poolId__address
  poolId__alpha
  poolId__amp
  poolId__baseToken
  poolId__beta
  poolId__c
  poolId__createTime
  poolId__dSq
  poolId__delta
  poolId__epsilon
  poolId__expiryTime
  poolId__factory
  poolId__holdersCount
  poolId__id
  poolId__isInRecoveryMode
  poolId__isPaused
  poolId__joinExitEnabled
  poolId__lambda
  poolId__lastJoinExitAmp
  poolId__lastPostJoinExitInvariant
  poolId__lowerTarget
  poolId__mainIndex
  poolId__managementAumFee
  poolId__managementFee
  poolId__mustAllowlistLPs
  poolId__name
  poolId__oracleEnabled
  poolId__owner
  poolId__poolType
  poolId__poolTypeVersion
  poolId__principalToken
  poolId__protocolAumFeeCache
  poolId__protocolId
  poolId__protocolSwapFeeCache
  poolId__protocolYieldFeeCache
  poolId__root3Alpha
  poolId__s
  poolId__sqrtAlpha
  poolId__sqrtBeta
  poolId__strategyType
  poolId__swapEnabled
  poolId__swapEnabledCurationSignal
  poolId__swapEnabledInternal
  poolId__swapFee
  poolId__swapsCount
  poolId__symbol
  poolId__tauAlphaX
  poolId__tauAlphaY
  poolId__tauBetaX
  poolId__tauBetaY
  poolId__totalAumFeeCollectedInBPT
  poolId__totalLiquidity
  poolId__totalLiquiditySansBPT
  poolId__totalProtocolFee
  poolId__totalProtocolFeePaidInBPT
  poolId__totalShares
  poolId__totalSwapFee
  poolId__totalSwapVolume
  poolId__totalWeight
  poolId__tx
  poolId__u
  poolId__unitSeconds
  poolId__upperTarget
  poolId__v
  poolId__w
  poolId__wrappedIndex
  poolId__z
  timestamp
  tokenAmountIn
  tokenAmountOut
  tokenIn
  tokenInSym
  tokenOut
  tokenOutSym
  tx
  userAddress
  userAddress__id
  valueUSD
}

"""
A string representation of microseconds UNIX timestamp (16 digits)
"""
scalar Timestamp

type Token {
  address: String!
  decimals: Int!
  fxOracleDecimals: Int
  id: ID!
  latestFXPrice: BigDecimal
  latestPrice: LatestPrice
  latestUSDPrice: BigDecimal
  latestUSDPriceTimestamp: BigInt
  name: String
  pool: Pool
  symbol: String
  totalBalanceNotional: BigDecimal!
  totalBalanceUSD: BigDecimal!
  totalSwapCount: BigInt!
  totalVolumeNotional: BigDecimal!
  totalVolumeUSD: BigDecimal!
}

type TokenPrice {
  amount: BigDecimal!
  asset: Bytes!
  block: BigInt!
  id: ID!
  poolId: Pool!
  price: BigDecimal!
  pricingAsset: Bytes!
  timestamp: Int!
}

input TokenPrice_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  amount: BigDecimal
  amount_gt: BigDecimal
  amount_gte: BigDecimal
  amount_in: [BigDecimal!]
  amount_lt: BigDecimal
  amount_lte: BigDecimal
  amount_not: BigDecimal
  amount_not_in: [BigDecimal!]
  and: [TokenPrice_filter]
  asset: Bytes
  asset_contains: Bytes
  asset_gt: Bytes
  asset_gte: Bytes
  asset_in: [Bytes!]
  asset_lt: Bytes
  asset_lte: Bytes
  asset_not: Bytes
  asset_not_contains: Bytes
  asset_not_in: [Bytes!]
  block: BigInt
  block_gt: BigInt
  block_gte: BigInt
  block_in: [BigInt!]
  block_lt: BigInt
  block_lte: BigInt
  block_not: BigInt
  block_not_in: [BigInt!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [TokenPrice_filter]
  poolId: String
  poolId_: Pool_filter
  poolId_contains: String
  poolId_contains_nocase: String
  poolId_ends_with: String
  poolId_ends_with_nocase: String
  poolId_gt: String
  poolId_gte: String
  poolId_in: [String!]
  poolId_lt: String
  poolId_lte: String
  poolId_not: String
  poolId_not_contains: String
  poolId_not_contains_nocase: String
  poolId_not_ends_with: String
  poolId_not_ends_with_nocase: String
  poolId_not_in: [String!]
  poolId_not_starts_with: String
  poolId_not_starts_with_nocase: String
  poolId_starts_with: String
  poolId_starts_with_nocase: String
  price: BigDecimal
  price_gt: BigDecimal
  price_gte: BigDecimal
  price_in: [BigDecimal!]
  price_lt: BigDecimal
  price_lte: BigDecimal
  price_not: BigDecimal
  price_not_in: [BigDecimal!]
  pricingAsset: Bytes
  pricingAsset_contains: Bytes
  pricingAsset_gt: Bytes
  pricingAsset_gte: Bytes
  pricingAsset_in: [Bytes!]
  pricingAsset_lt: Bytes
  pricingAsset_lte: Bytes
  pricingAsset_not: Bytes
  pricingAsset_not_contains: Bytes
  pricingAsset_not_in: [Bytes!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
}

enum TokenPrice_orderBy {
  amount
  asset
  block
  id
  poolId
  poolId__address
  poolId__alpha
  poolId__amp
  poolId__baseToken
  poolId__beta
  poolId__c
  poolId__createTime
  poolId__dSq
  poolId__delta
  poolId__epsilon
  poolId__expiryTime
  poolId__factory
  poolId__holdersCount
  poolId__id
  poolId__isInRecoveryMode
  poolId__isPaused
  poolId__joinExitEnabled
  poolId__lambda
  poolId__lastJoinExitAmp
  poolId__lastPostJoinExitInvariant
  poolId__lowerTarget
  poolId__mainIndex
  poolId__managementAumFee
  poolId__managementFee
  poolId__mustAllowlistLPs
  poolId__name
  poolId__oracleEnabled
  poolId__owner
  poolId__poolType
  poolId__poolTypeVersion
  poolId__principalToken
  poolId__protocolAumFeeCache
  poolId__protocolId
  poolId__protocolSwapFeeCache
  poolId__protocolYieldFeeCache
  poolId__root3Alpha
  poolId__s
  poolId__sqrtAlpha
  poolId__sqrtBeta
  poolId__strategyType
  poolId__swapEnabled
  poolId__swapEnabledCurationSignal
  poolId__swapEnabledInternal
  poolId__swapFee
  poolId__swapsCount
  poolId__symbol
  poolId__tauAlphaX
  poolId__tauAlphaY
  poolId__tauBetaX
  poolId__tauBetaY
  poolId__totalAumFeeCollectedInBPT
  poolId__totalLiquidity
  poolId__totalLiquiditySansBPT
  poolId__totalProtocolFee
  poolId__totalProtocolFeePaidInBPT
  poolId__totalShares
  poolId__totalSwapFee
  poolId__totalSwapVolume
  poolId__totalWeight
  poolId__tx
  poolId__u
  poolId__unitSeconds
  poolId__upperTarget
  poolId__v
  poolId__w
  poolId__wrappedIndex
  poolId__z
  price
  pricingAsset
  timestamp
}

type TokenSnapshot {
  id: ID!
  timestamp: Int!
  token: Token!
  totalBalanceNotional: BigDecimal!
  totalBalanceUSD: BigDecimal!
  totalSwapCount: BigInt!
  totalVolumeNotional: BigDecimal!
  totalVolumeUSD: BigDecimal!
}

input TokenSnapshot_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [TokenSnapshot_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [TokenSnapshot_filter]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  token: String
  token_: Token_filter
  token_contains: String
  token_contains_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  totalBalanceNotional: BigDecimal
  totalBalanceNotional_gt: BigDecimal
  totalBalanceNotional_gte: BigDecimal
  totalBalanceNotional_in: [BigDecimal!]
  totalBalanceNotional_lt: BigDecimal
  totalBalanceNotional_lte: BigDecimal
  totalBalanceNotional_not: BigDecimal
  totalBalanceNotional_not_in: [BigDecimal!]
  totalBalanceUSD: BigDecimal
  totalBalanceUSD_gt: BigDecimal
  totalBalanceUSD_gte: BigDecimal
  totalBalanceUSD_in: [BigDecimal!]
  totalBalanceUSD_lt: BigDecimal
  totalBalanceUSD_lte: BigDecimal
  totalBalanceUSD_not: BigDecimal
  totalBalanceUSD_not_in: [BigDecimal!]
  totalSwapCount: BigInt
  totalSwapCount_gt: BigInt
  totalSwapCount_gte: BigInt
  totalSwapCount_in: [BigInt!]
  totalSwapCount_lt: BigInt
  totalSwapCount_lte: BigInt
  totalSwapCount_not: BigInt
  totalSwapCount_not_in: [BigInt!]
  totalVolumeNotional: BigDecimal
  totalVolumeNotional_gt: BigDecimal
  totalVolumeNotional_gte: BigDecimal
  totalVolumeNotional_in: [BigDecimal!]
  totalVolumeNotional_lt: BigDecimal
  totalVolumeNotional_lte: BigDecimal
  totalVolumeNotional_not: BigDecimal
  totalVolumeNotional_not_in: [BigDecimal!]
  totalVolumeUSD: BigDecimal
  totalVolumeUSD_gt: BigDecimal
  totalVolumeUSD_gte: BigDecimal
  totalVolumeUSD_in: [BigDecimal!]
  totalVolumeUSD_lt: BigDecimal
  totalVolumeUSD_lte: BigDecimal
  totalVolumeUSD_not: BigDecimal
  totalVolumeUSD_not_in: [BigDecimal!]
}

enum TokenSnapshot_orderBy {
  id
  timestamp
  token
  token__address
  token__decimals
  token__fxOracleDecimals
  token__id
  token__latestFXPrice
  token__latestUSDPrice
  token__latestUSDPriceTimestamp
  token__name
  token__symbol
  token__totalBalanceNotional
  token__totalBalanceUSD
  token__totalSwapCount
  token__totalVolumeNotional
  token__totalVolumeUSD
  totalBalanceNotional
  totalBalanceUSD
  totalSwapCount
  totalVolumeNotional
  totalVolumeUSD
}

input Token_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  address: String
  address_contains: String
  address_contains_nocase: String
  address_ends_with: String
  address_ends_with_nocase: String
  address_gt: String
  address_gte: String
  address_in: [String!]
  address_lt: String
  address_lte: String
  address_not: String
  address_not_contains: String
  address_not_contains_nocase: String
  address_not_ends_with: String
  address_not_ends_with_nocase: String
  address_not_in: [String!]
  address_not_starts_with: String
  address_not_starts_with_nocase: String
  address_starts_with: String
  address_starts_with_nocase: String
  and: [Token_filter]
  decimals: Int
  decimals_gt: Int
  decimals_gte: Int
  decimals_in: [Int!]
  decimals_lt: Int
  decimals_lte: Int
  decimals_not: Int
  decimals_not_in: [Int!]
  fxOracleDecimals: Int
  fxOracleDecimals_gt: Int
  fxOracleDecimals_gte: Int
  fxOracleDecimals_in: [Int!]
  fxOracleDecimals_lt: Int
  fxOracleDecimals_lte: Int
  fxOracleDecimals_not: Int
  fxOracleDecimals_not_in: [Int!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  latestFXPrice: BigDecimal
  latestFXPrice_gt: BigDecimal
  latestFXPrice_gte: BigDecimal
  latestFXPrice_in: [BigDecimal!]
  latestFXPrice_lt: BigDecimal
  latestFXPrice_lte: BigDecimal
  latestFXPrice_not: BigDecimal
  latestFXPrice_not_in: [BigDecimal!]
  latestPrice: String
  latestPrice_: LatestPrice_filter
  latestPrice_contains: String
  latestPrice_contains_nocase: String
  latestPrice_ends_with: String
  latestPrice_ends_with_nocase: String
  latestPrice_gt: String
  latestPrice_gte: String
  latestPrice_in: [String!]
  latestPrice_lt: String
  latestPrice_lte: String
  latestPrice_not: String
  latestPrice_not_contains: String
  latestPrice_not_contains_nocase: String
  latestPrice_not_ends_with: String
  latestPrice_not_ends_with_nocase: String
  latestPrice_not_in: [String!]
  latestPrice_not_starts_with: String
  latestPrice_not_starts_with_nocase: String
  latestPrice_starts_with: String
  latestPrice_starts_with_nocase: String
  latestUSDPrice: BigDecimal
  latestUSDPriceTimestamp: BigInt
  latestUSDPriceTimestamp_gt: BigInt
  latestUSDPriceTimestamp_gte: BigInt
  latestUSDPriceTimestamp_in: [BigInt!]
  latestUSDPriceTimestamp_lt: BigInt
  latestUSDPriceTimestamp_lte: BigInt
  latestUSDPriceTimestamp_not: BigInt
  latestUSDPriceTimestamp_not_in: [BigInt!]
  latestUSDPrice_gt: BigDecimal
  latestUSDPrice_gte: BigDecimal
  latestUSDPrice_in: [BigDecimal!]
  latestUSDPrice_lt: BigDecimal
  latestUSDPrice_lte: BigDecimal
  latestUSDPrice_not: BigDecimal
  latestUSDPrice_not_in: [BigDecimal!]
  name: String
  name_contains: String
  name_contains_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  or: [Token_filter]
  pool: String
  pool_: Pool_filter
  pool_contains: String
  pool_contains_nocase: String
  pool_ends_with: String
  pool_ends_with_nocase: String
  pool_gt: String
  pool_gte: String
  pool_in: [String!]
  pool_lt: String
  pool_lte: String
  pool_not: String
  pool_not_contains: String
  pool_not_contains_nocase: String
  pool_not_ends_with: String
  pool_not_ends_with_nocase: String
  pool_not_in: [String!]
  pool_not_starts_with: String
  pool_not_starts_with_nocase: String
  pool_starts_with: String
  pool_starts_with_nocase: String
  symbol: String
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_gt: String
  symbol_gte: String
  symbol_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_not: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  symbol_not_in: [String!]
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  totalBalanceNotional: BigDecimal
  totalBalanceNotional_gt: BigDecimal
  totalBalanceNotional_gte: BigDecimal
  totalBalanceNotional_in: [BigDecimal!]
  totalBalanceNotional_lt: BigDecimal
  totalBalanceNotional_lte: BigDecimal
  totalBalanceNotional_not: BigDecimal
  totalBalanceNotional_not_in: [BigDecimal!]
  totalBalanceUSD: BigDecimal
  totalBalanceUSD_gt: BigDecimal
  totalBalanceUSD_gte: BigDecimal
  totalBalanceUSD_in: [BigDecimal!]
  totalBalanceUSD_lt: BigDecimal
  totalBalanceUSD_lte: BigDecimal
  totalBalanceUSD_not: BigDecimal
  totalBalanceUSD_not_in: [BigDecimal!]
  totalSwapCount: BigInt
  totalSwapCount_gt: BigInt
  totalSwapCount_gte: BigInt
  totalSwapCount_in: [BigInt!]
  totalSwapCount_lt: BigInt
  totalSwapCount_lte: BigInt
  totalSwapCount_not: BigInt
  totalSwapCount_not_in: [BigInt!]
  totalVolumeNotional: BigDecimal
  totalVolumeNotional_gt: BigDecimal
  totalVolumeNotional_gte: BigDecimal
  totalVolumeNotional_in: [BigDecimal!]
  totalVolumeNotional_lt: BigDecimal
  totalVolumeNotional_lte: BigDecimal
  totalVolumeNotional_not: BigDecimal
  totalVolumeNotional_not_in: [BigDecimal!]
  totalVolumeUSD: BigDecimal
  totalVolumeUSD_gt: BigDecimal
  totalVolumeUSD_gte: BigDecimal
  totalVolumeUSD_in: [BigDecimal!]
  totalVolumeUSD_lt: BigDecimal
  totalVolumeUSD_lte: BigDecimal
  totalVolumeUSD_not: BigDecimal
  totalVolumeUSD_not_in: [BigDecimal!]
}

enum Token_orderBy {
  address
  decimals
  fxOracleDecimals
  id
  latestFXPrice
  latestPrice
  latestPrice__asset
  latestPrice__block
  latestPrice__id
  latestPrice__price
  latestPrice__pricingAsset
  latestUSDPrice
  latestUSDPriceTimestamp
  name
  pool
  pool__address
  pool__alpha
  pool__amp
  pool__baseToken
  pool__beta
  pool__c
  pool__createTime
  pool__dSq
  pool__delta
  pool__epsilon
  pool__expiryTime
  pool__factory
  pool__holdersCount
  pool__id
  pool__isInRecoveryMode
  pool__isPaused
  pool__joinExitEnabled
  pool__lambda
  pool__lastJoinExitAmp
  pool__lastPostJoinExitInvariant
  pool__lowerTarget
  pool__mainIndex
  pool__managementAumFee
  pool__managementFee
  pool__mustAllowlistLPs
  pool__name
  pool__oracleEnabled
  pool__owner
  pool__poolType
  pool__poolTypeVersion
  pool__principalToken
  pool__protocolAumFeeCache
  pool__protocolId
  pool__protocolSwapFeeCache
  pool__protocolYieldFeeCache
  pool__root3Alpha
  pool__s
  pool__sqrtAlpha
  pool__sqrtBeta
  pool__strategyType
  pool__swapEnabled
  pool__swapEnabledCurationSignal
  pool__swapEnabledInternal
  pool__swapFee
  pool__swapsCount
  pool__symbol
  pool__tauAlphaX
  pool__tauAlphaY
  pool__tauBetaX
  pool__tauBetaY
  pool__totalAumFeeCollectedInBPT
  pool__totalLiquidity
  pool__totalLiquiditySansBPT
  pool__totalProtocolFee
  pool__totalProtocolFeePaidInBPT
  pool__totalShares
  pool__totalSwapFee
  pool__totalSwapVolume
  pool__totalWeight
  pool__tx
  pool__u
  pool__unitSeconds
  pool__upperTarget
  pool__v
  pool__w
  pool__wrappedIndex
  pool__z
  symbol
  totalBalanceNotional
  totalBalanceUSD
  totalSwapCount
  totalVolumeNotional
  totalVolumeUSD
}

type TradePair {
  """
  Token Address - Token Address
  """
  id: ID!
  token0: Token!
  token1: Token!
  totalSwapFee: BigDecimal!
  totalSwapVolume: BigDecimal!
}

type TradePairSnapshot {
  id: ID!
  pair: TradePair!
  timestamp: Int!
  totalSwapFee: BigDecimal!
  totalSwapVolume: BigDecimal!
}

input TradePairSnapshot_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [TradePairSnapshot_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [TradePairSnapshot_filter]
  pair: String
  pair_: TradePair_filter
  pair_contains: String
  pair_contains_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_gt: String
  pair_gte: String
  pair_in: [String!]
  pair_lt: String
  pair_lte: String
  pair_not: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  pair_not_in: [String!]
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  totalSwapFee: BigDecimal
  totalSwapFee_gt: BigDecimal
  totalSwapFee_gte: BigDecimal
  totalSwapFee_in: [BigDecimal!]
  totalSwapFee_lt: BigDecimal
  totalSwapFee_lte: BigDecimal
  totalSwapFee_not: BigDecimal
  totalSwapFee_not_in: [BigDecimal!]
  totalSwapVolume: BigDecimal
  totalSwapVolume_gt: BigDecimal
  totalSwapVolume_gte: BigDecimal
  totalSwapVolume_in: [BigDecimal!]
  totalSwapVolume_lt: BigDecimal
  totalSwapVolume_lte: BigDecimal
  totalSwapVolume_not: BigDecimal
  totalSwapVolume_not_in: [BigDecimal!]
}

enum TradePairSnapshot_orderBy {
  id
  pair
  pair__id
  pair__totalSwapFee
  pair__totalSwapVolume
  timestamp
  totalSwapFee
  totalSwapVolume
}

input TradePair_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [TradePair_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [TradePair_filter]
  token0: String
  token0_: Token_filter
  token0_contains: String
  token0_contains_nocase: String
  token0_ends_with: String
  token0_ends_with_nocase: String
  token0_gt: String
  token0_gte: String
  token0_in: [String!]
  token0_lt: String
  token0_lte: String
  token0_not: String
  token0_not_contains: String
  token0_not_contains_nocase: String
  token0_not_ends_with: String
  token0_not_ends_with_nocase: String
  token0_not_in: [String!]
  token0_not_starts_with: String
  token0_not_starts_with_nocase: String
  token0_starts_with: String
  token0_starts_with_nocase: String
  token1: String
  token1_: Token_filter
  token1_contains: String
  token1_contains_nocase: String
  token1_ends_with: String
  token1_ends_with_nocase: String
  token1_gt: String
  token1_gte: String
  token1_in: [String!]
  token1_lt: String
  token1_lte: String
  token1_not: String
  token1_not_contains: String
  token1_not_contains_nocase: String
  token1_not_ends_with: String
  token1_not_ends_with_nocase: String
  token1_not_in: [String!]
  token1_not_starts_with: String
  token1_not_starts_with_nocase: String
  token1_starts_with: String
  token1_starts_with_nocase: String
  totalSwapFee: BigDecimal
  totalSwapFee_gt: BigDecimal
  totalSwapFee_gte: BigDecimal
  totalSwapFee_in: [BigDecimal!]
  totalSwapFee_lt: BigDecimal
  totalSwapFee_lte: BigDecimal
  totalSwapFee_not: BigDecimal
  totalSwapFee_not_in: [BigDecimal!]
  totalSwapVolume: BigDecimal
  totalSwapVolume_gt: BigDecimal
  totalSwapVolume_gte: BigDecimal
  totalSwapVolume_in: [BigDecimal!]
  totalSwapVolume_lt: BigDecimal
  totalSwapVolume_lte: BigDecimal
  totalSwapVolume_not: BigDecimal
  totalSwapVolume_not_in: [BigDecimal!]
}

enum TradePair_orderBy {
  id
  token0
  token0__address
  token0__decimals
  token0__fxOracleDecimals
  token0__id
  token0__latestFXPrice
  token0__latestUSDPrice
  token0__latestUSDPriceTimestamp
  token0__name
  token0__symbol
  token0__totalBalanceNotional
  token0__totalBalanceUSD
  token0__totalSwapCount
  token0__totalVolumeNotional
  token0__totalVolumeUSD
  token1
  token1__address
  token1__decimals
  token1__fxOracleDecimals
  token1__id
  token1__latestFXPrice
  token1__latestUSDPrice
  token1__latestUSDPriceTimestamp
  token1__name
  token1__symbol
  token1__totalBalanceNotional
  token1__totalBalanceUSD
  token1__totalSwapCount
  token1__totalVolumeNotional
  token1__totalVolumeUSD
  totalSwapFee
  totalSwapVolume
}

type User {
  """
  List of gauge the user has shares
  """
  gaugeShares(
    first: Int = 100
    orderBy: GaugeShare_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: GaugeShare_filter
  ): [GaugeShare!]

  """
  List of votes on gauges
  """
  gaugeVotes(
    first: Int = 100
    orderBy: GaugeVote_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: GaugeVote_filter
  ): [GaugeVote!]

  """
  User address
  """
  id: ID!

  """
  List of omni locks the user created
  """
  omniVotingLocks(
    first: Int = 100
    orderBy: OmniVotingEscrowLock_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: OmniVotingEscrowLock_filter
  ): [OmniVotingEscrowLock!]
  sharesOwned(
    first: Int = 100
    orderBy: PoolShare_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: PoolShare_filter
  ): [PoolShare!]
  swaps(
    first: Int = 100
    orderBy: Swap_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: Swap_filter
  ): [Swap!]
  userInternalBalances(
    first: Int = 100
    orderBy: UserInternalBalance_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: UserInternalBalance_filter
  ): [UserInternalBalance!]

  """
  List of locks the user created
  """
  votingLocks(
    first: Int = 100
    orderBy: VotingEscrowLock_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VotingEscrowLock_filter
  ): [VotingEscrowLock!]
}

type UserInternalBalance {
  balance: BigDecimal!
  id: ID!
  token: Bytes!
  tokenInfo: Token
  userAddress: User
}

input UserInternalBalance_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [UserInternalBalance_filter]
  balance: BigDecimal
  balance_gt: BigDecimal
  balance_gte: BigDecimal
  balance_in: [BigDecimal!]
  balance_lt: BigDecimal
  balance_lte: BigDecimal
  balance_not: BigDecimal
  balance_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  or: [UserInternalBalance_filter]
  token: Bytes
  tokenInfo: String
  tokenInfo_: Token_filter
  tokenInfo_contains: String
  tokenInfo_contains_nocase: String
  tokenInfo_ends_with: String
  tokenInfo_ends_with_nocase: String
  tokenInfo_gt: String
  tokenInfo_gte: String
  tokenInfo_in: [String!]
  tokenInfo_lt: String
  tokenInfo_lte: String
  tokenInfo_not: String
  tokenInfo_not_contains: String
  tokenInfo_not_contains_nocase: String
  tokenInfo_not_ends_with: String
  tokenInfo_not_ends_with_nocase: String
  tokenInfo_not_in: [String!]
  tokenInfo_not_starts_with: String
  tokenInfo_not_starts_with_nocase: String
  tokenInfo_starts_with: String
  tokenInfo_starts_with_nocase: String
  token_contains: Bytes
  token_gt: Bytes
  token_gte: Bytes
  token_in: [Bytes!]
  token_lt: Bytes
  token_lte: Bytes
  token_not: Bytes
  token_not_contains: Bytes
  token_not_in: [Bytes!]
  userAddress: String
  userAddress_: User_filter
  userAddress_contains: String
  userAddress_contains_nocase: String
  userAddress_ends_with: String
  userAddress_ends_with_nocase: String
  userAddress_gt: String
  userAddress_gte: String
  userAddress_in: [String!]
  userAddress_lt: String
  userAddress_lte: String
  userAddress_not: String
  userAddress_not_contains: String
  userAddress_not_contains_nocase: String
  userAddress_not_ends_with: String
  userAddress_not_ends_with_nocase: String
  userAddress_not_in: [String!]
  userAddress_not_starts_with: String
  userAddress_not_starts_with_nocase: String
  userAddress_starts_with: String
  userAddress_starts_with_nocase: String
}

enum UserInternalBalance_orderBy {
  balance
  id
  token
  tokenInfo
  tokenInfo__address
  tokenInfo__decimals
  tokenInfo__fxOracleDecimals
  tokenInfo__id
  tokenInfo__latestFXPrice
  tokenInfo__latestUSDPrice
  tokenInfo__latestUSDPriceTimestamp
  tokenInfo__name
  tokenInfo__symbol
  tokenInfo__totalBalanceNotional
  tokenInfo__totalBalanceUSD
  tokenInfo__totalSwapCount
  tokenInfo__totalVolumeNotional
  tokenInfo__totalVolumeUSD
  userAddress
  userAddress__id
}

input User_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [User_filter]
  gaugeShares_: GaugeShare_filter
  gaugeVotes_: GaugeVote_filter
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  omniVotingLocks_: OmniVotingEscrowLock_filter
  or: [User_filter]
  sharesOwned_: PoolShare_filter
  swaps_: Swap_filter
  userInternalBalances_: UserInternalBalance_filter
  votingLocks_: VotingEscrowLock_filter
}

enum User_orderBy {
  gaugeShares
  gaugeVotes
  id
  omniVotingLocks
  sharesOwned
  swaps
  userInternalBalances
  votingLocks
}

type VotingEscrow {
  """
  VotingEscrow contract address
  """
  id: ID!

  """
  List of veBAL locks created
  """
  locks(
    first: Int = 100
    orderBy: VotingEscrowLock_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: VotingEscrowLock_filter
  ): [VotingEscrowLock!]

  """
  List of veBAL locks created
  """
  omniLocks(
    first: Int = 100
    orderBy: OmniVotingEscrowLock_orderBy
    orderDirection: OrderDirection
    skip: Int = 0
    where: OmniVotingEscrowLock_filter
  ): [OmniVotingEscrowLock!]

  """
  Amount of B-80BAL-20WETH BPT locked, only applies on mainnet
  """
  stakedSupply: BigDecimal
}

type VotingEscrowLock {
  """
  veBAL balance at the moment user locks
  """
  bias: BigDecimal!

  """
  Equal to: <userAdress>-<votingEscrow>
  """
  id: ID!

  """
  Amount of B-80BAL-20WETH BPT the user has locked
  """
  lockedBalance: BigDecimal!

  """
  veBAL decay rate (per second)
  """
  slope: BigDecimal!

  """
  Timestamp at which the lock was created [seconds]
  """
  timestamp: Int!

  """
  Timestamp at which B-80BAL-20WETH BPT can be unlocked by user [seconds]
  """
  unlockTime: BigInt!

  """
  Timestamp at which the lcok was created [seconds]. Same as timestamp
  """
  updatedAt: Int!

  """
  Reference to User entity
  """
  user: User!

  """
  Reference to VotingEscrow entity
  """
  votingEscrowID: VotingEscrow!
}

input VotingEscrowLock_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [VotingEscrowLock_filter]
  bias: BigDecimal
  bias_gt: BigDecimal
  bias_gte: BigDecimal
  bias_in: [BigDecimal!]
  bias_lt: BigDecimal
  bias_lte: BigDecimal
  bias_not: BigDecimal
  bias_not_in: [BigDecimal!]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  lockedBalance: BigDecimal
  lockedBalance_gt: BigDecimal
  lockedBalance_gte: BigDecimal
  lockedBalance_in: [BigDecimal!]
  lockedBalance_lt: BigDecimal
  lockedBalance_lte: BigDecimal
  lockedBalance_not: BigDecimal
  lockedBalance_not_in: [BigDecimal!]
  or: [VotingEscrowLock_filter]
  slope: BigDecimal
  slope_gt: BigDecimal
  slope_gte: BigDecimal
  slope_in: [BigDecimal!]
  slope_lt: BigDecimal
  slope_lte: BigDecimal
  slope_not: BigDecimal
  slope_not_in: [BigDecimal!]
  timestamp: Int
  timestamp_gt: Int
  timestamp_gte: Int
  timestamp_in: [Int!]
  timestamp_lt: Int
  timestamp_lte: Int
  timestamp_not: Int
  timestamp_not_in: [Int!]
  unlockTime: BigInt
  unlockTime_gt: BigInt
  unlockTime_gte: BigInt
  unlockTime_in: [BigInt!]
  unlockTime_lt: BigInt
  unlockTime_lte: BigInt
  unlockTime_not: BigInt
  unlockTime_not_in: [BigInt!]
  updatedAt: Int
  updatedAt_gt: Int
  updatedAt_gte: Int
  updatedAt_in: [Int!]
  updatedAt_lt: Int
  updatedAt_lte: Int
  updatedAt_not: Int
  updatedAt_not_in: [Int!]
  user: String
  user_: User_filter
  user_contains: String
  user_contains_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_gt: String
  user_gte: String
  user_in: [String!]
  user_lt: String
  user_lte: String
  user_not: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_not_in: [String!]
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
  votingEscrowID: String
  votingEscrowID_: VotingEscrow_filter
  votingEscrowID_contains: String
  votingEscrowID_contains_nocase: String
  votingEscrowID_ends_with: String
  votingEscrowID_ends_with_nocase: String
  votingEscrowID_gt: String
  votingEscrowID_gte: String
  votingEscrowID_in: [String!]
  votingEscrowID_lt: String
  votingEscrowID_lte: String
  votingEscrowID_not: String
  votingEscrowID_not_contains: String
  votingEscrowID_not_contains_nocase: String
  votingEscrowID_not_ends_with: String
  votingEscrowID_not_ends_with_nocase: String
  votingEscrowID_not_in: [String!]
  votingEscrowID_not_starts_with: String
  votingEscrowID_not_starts_with_nocase: String
  votingEscrowID_starts_with: String
  votingEscrowID_starts_with_nocase: String
}

enum VotingEscrowLock_orderBy {
  bias
  id
  lockedBalance
  slope
  timestamp
  unlockTime
  updatedAt
  user
  user__id
  votingEscrowID
  votingEscrowID__id
  votingEscrowID__stakedSupply
}

input VotingEscrow_filter {
  """
  Filter for the block changed event.
  """
  _change_block: BlockChangedFilter
  and: [VotingEscrow_filter]
  id: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_in: [ID!]
  locks_: VotingEscrowLock_filter
  omniLocks_: OmniVotingEscrowLock_filter
  or: [VotingEscrow_filter]
  stakedSupply: BigDecimal
  stakedSupply_gt: BigDecimal
  stakedSupply_gte: BigDecimal
  stakedSupply_in: [BigDecimal!]
  stakedSupply_lt: BigDecimal
  stakedSupply_lte: BigDecimal
  stakedSupply_not: BigDecimal
  stakedSupply_not_in: [BigDecimal!]
}

enum VotingEscrow_orderBy {
  id
  locks
  omniLocks
  stakedSupply
}

type _Block_ {
  """
  The hash of the block
  """
  hash: Bytes

  """
  The block number
  """
  number: Int!

  """
  The hash of the parent block
  """
  parentHash: Bytes

  """
  Integer representation of the timestamp stored in blocks for the chain
  """
  timestamp: Int
}

"""
The type for the top-level _meta field
"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  """
  block: _Block_!

  """
  The deployment ID
  """
  deployment: String!

  """
  If `true`, the subgraph encountered indexing errors at some past block
  """
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """
  Data will be returned even if the subgraph has indexing errors
  """
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}
